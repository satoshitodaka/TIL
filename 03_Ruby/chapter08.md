## 8-1 クラスとは
#### オブジェクトはクラスに属している
- クラスとは、オブジェクトの種類を表すもの。
- オブジェクトが属しているクラスはclassメソッドで調べることができる。
- クラスに属するオブジェクトを、そのクラスのインスタンスである、とも言える。
- 全てのオブジェクトはいずれかのクラスに属している。
#### オブジェクトを作る２つの方法
- putsで指定する方法（あまり意識してなかった作り方）
- クラスとnewメソッドを使ってオブジェクトを作る方法」

## 8-2 クラスを作る
#### クラスを作る
- クラスを作る際は、classでクラス名を宣言する。
```
class User
end
```
## 8-3 オブジェクトが呼び出せるメソッドを作る
#### レシーバ
- レシーバとは、メソッドを呼び出されるオブジェクトのこと。
- methodsメソッドでは、レシーバ（オブジェクト）に対して使用できるメソッドの一覧を取得できる。自分で作成したクラスのインスタンスにmethodsを使えば、定義したメソッドが表示される。 
#### クラスの中で同じクラスのメソッドを呼び出す
- クラスメソッドにおいて、レシーバと.を省略して書くことができる。この場合は実行中のレシーバに対して処理がなされる。
- レシーバが何かわからなくなった場合、途中にp selfを差し込むと確認できる。

## 8-4 オブジェクトにデータを持たせる
#### インスタンス変数
- ローカル変数は、メソッドをまたいで使用できない。（スコープの範囲はメソッド内）
- インスタンス変数はより広いスコープを持つため、メソッドをまたいで使用することができる。インスタンス（オブジェクト）の変数であるため、寿命もインスタンスと同様。インスタンス変数は@を付けることで作成できる。
- インスタンス変数の寿命は、作成されたインスタンス(クラス.newなど)に依存する。
#### インスタンス変数はオブジェクト毎に存在する。
-  インスタンス変数（の値）はオブジェクト毎に存在する。そのため、インスタンスが異なれば、同じクラスのインスタンス変数でも違う値となる。
#### インスタンス変数を取得するメソッドを作る
- オブジェクトが持つインスタンス変数は、そのままでは取得できない。
- クラス内にインスタンス変数を戻り値とするメソッドを追加して呼び出す。
```
# NG
class Drink
  def order(item)
    puts "#{item}をください"
    @name = item
  end
end

drink = Drink.new
drink.order("カフェラテ")
puts drink.@name


# OK
class Drink
  def order(item)
    puts "#{item}をください"
    @name = item
  end
  
  def name
   @name
  end
end

drink = Drink.new
drink.order("カフェラテ")
puts drink.name

```
- インスタンス変数に代入するメソッドは、インスタンス変数から@を除き、末尾に=をつけることが多い（慣習となっている）。このように末尾が=で終わるメソッドは、呼び出す際にメソッド名と=の間にスペースをあけることができ、感覚的にわかりやすい表記にすることができる。
```
class Drink
  def name=(text)
    @name = text
  end
  def name
    @name
  end
end
drink = Drink.new
drink.name = "カフェラテ"
puts drink.name
```

#### instance_valiablesメソッド
- オブジェクトに対してinstance_valiablesメソッドを使うと、持っている全てのインスタンス変数を返す。

## 8-5 オブジェクトが作られるときに処理を行う。
オブジェクトが作られるときに、インスタンス変数に最初からデータを持たせると便利なケースがある。
#### initializeメソッド 
- クラスにはinitializeメソッドが用意されている。initializeメソッドを作ると、オブジェクトを新しく作る際に自動で呼び出される。
#### インスタンス変数の初期値を設定する。
- initializeが有効な場面として、インスタンス変数の初期値を設定することがある。
#### initializeメソッドへ引数を渡す。
- 前項で設定したinitializeで任意の値を設定するために、引数を渡すことができる。
## 8-6 クラスを使ってメソッドを呼び出す
#### インスタンスメソッドとクラスメソッド
- クラスに作るメソッドには2種類あり、インスタンスメソッドとクラスメソッド。2つの違いは、レシーバがインスタンスかクラスか。
#### クラスメソッドを定義する
- クラスメソッドを定義するには、defのメソッド名の前にself.をつける。
- クラスメソッドはクラスが実行するので、オブジェクトを作らずに実行できる。
#### #記法と.記法
- ドキュメントでは、インスタンスメソッドとクラスメソッドには記法がある。
- インスタンスメソッドは、クラス名#メソッド名と書く。
- クラスメソッドは、クラス名.メソッド名とかく。
- クラスメソッドはクラス::名メソッド名と書くこともある。
#### 同じクラスのクラスメソッドを呼び出す
- クラスメソッドの中で同じクラスのクラスメソッドを呼び出す際は、メソッド名だけでOK。レシーバを省略しないで書く場合はself.メソッド名、クラス.メソッド名と書けばOK。
- インスタンスメソッドからクラスメソッドを呼び出すことができる。Self.class.メソッド名、と書く。
- クラスメソッドはインスタンスメソッドを呼び出せない。クラスメソッドはインスタンスメソッドを決める（作る？）ものではないから。
#### クラスメソッドの定義方法
- class <<  selfと書くと、その中でクラスメソッドをまとめて定義できる。
- また、def クラス名.メソッド名と書くこともできる。

## 8-7 継承を使ってクラスをわける
#### 継承
- クラスの継承を使うと、親となるクラスの要素（メソッドなど）を引き継ぐ。
- クラスを定義する際は以下のように記述する。
```
class サブクラス（子） < スーバークラス（親）
end
``` 
#### クラスの継承関係を知る
- クラスの継承関係はancestorsメソッドで知ることができる。
- クラス名.ancestorsで継承関係（親クラス群）を取得できる。
- 全てのオブジェクトの継承関係を辿ると、オブジェクトの基礎はBasicObjectであることがわかる。
#### オーバーライド（多分）
- 親と子で同じ名前のメソッドを定義した場合、自身のクラスで定義したメソッドが優先される。
#### 親クラスのメソッドを呼び出す
- 子クラスにて親クラスと同じ名前のメソッドと定義する場合、メソッドの中にsuperと記述すると、親クラスのメソッドを呼び出すことができる。

## 8-8 メソッドの呼び出しを制限する
#### クラスでのメソッド定義の中だけで呼び出せるメソッドを作る
- privateを使うと、レシーバを指定したメソッドの呼び出しを禁止することができる。
- privateとpubulic
クラス内で、privateを使わずに定義したメソッドはpublicになり、privateを記述した後のメソッドはprivateメソッドとなる。
- publicと記述すると以降のメソッドはpublicとなるが、一般的には明示せずにメソッドの前半にまとめることが多い。クラスの使い方を定めるメソッドはpublicなものが多く、前半に読んでもらう方が都合が良い。
- defの前にprivateを書くことで、メソッド単体に適用できる。
```
Class Foo
	Private def a
	End
	Def b
	End
end
```
#### privateなクラスメソッドを定義する
- クラスメソッドをprivateで定義するには、以下いずれかの方法で定義する。
```
Class Foo
	Private_class_method def self.a
		'method a'
	End
end
```
```
class Foo
	Class << self
		Private
		'method a'
	End
end
```
