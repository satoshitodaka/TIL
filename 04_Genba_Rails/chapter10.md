## 10-2
#### 2-2 bundle update の留意点
-  bundleupdate のコマンドを実行する。
###### 2-1バージョンが上がったgemを確認する。 
- ログやGemfile.lock をgit diff で確認する。
###### 2-2 バージョンアップが妥当であったかどうか調査する。
- gem のリポジトリの変更履歴やリリースノートから理解する。（GitHubに記載のことが多い）コミットログやバージョン間の差分、リリースノート等を見て変更内容を把握する。メジャーバージョンが上がった場合は念入りに確認すること。
###### 2-3 バージョンアップ内容に問題があrugem のバージョンを戻す。
- バージョンアップに問題があると感じた場合は、古いバージョンをGemfile に記載して bundle アップデートを行う。
- 戻す場合は、バージョンを戻す（旧バージョンに固定する）理由をコメントで記載すること。また,bundle outdated で更新がないか定期的に確認すること。

## 10-3 
- bundle update はチーム全体でおこなうこと。
- そのためには、バージョンアップ当番制を導入することがおすすめ。

## 10 4 
- bundle update は自動化も可能だが、最終的な確認は人が行うこと。
## 10-5
- Ruby や Rails、その他大きいgem のバージョンアップがあった場合は、大きなバージョンアップを行う必要がある。
#### 考えられる戦略
- バージョンアップと追加機能リリースを並行する。バージョンアップブランチがmaster ブランチの変更を都度取り込み、不具合があれば修正する。
- まずはバージョンアップをリリースし、その後に追加機能をリリースする。
#### 気を付けるポイント
- 自動テストは十分か
- 動作確認方法
- リリース方法
- リリース後の動作確認と監視方法
- 万が一の場合のロールバック方法

## 10-7
#### 7-2 モデルに書くべきコードをモデルに寄せる
###### 2-1 多少変わった形の params からの代入コードをモデルに寄せる。
- 郵便番号が"-"を間に挟むなど、モデルでの扱いとビューのフォームに差がある（都度処理が被うつ用となる）場合、その処理をモデルに寄せることができる。
###### 2-2 オブジェクトの内部状態を変更するコードはモデルに寄せる。
###### 2-3 ビューに入り込んだビジネスロジックをモデルに寄せる。
- モデルに記述すべきロジックがビューに描かれると、様々な問題に繋がる。ビューの変更がビジネスロジックに影響する、ビューの数だけテストを書く必要がある、ロジックの修正の手間が増える、ビューテンプレートと相性が悪い、など。
###### 2-4 Decoratorパターンでモデル固有の表示ロジックを分離する。
- 原則として、ビジネスロジックはモデル、プレゼンテーションロジックはビューに記述する。
- モデル固有のプレゼンテーションロジックは原則に当てはめずらいので、Decoratorパターンを検討すると良い（よくわからん）

## 10-9
- コードを適切な場所に書くと、複雑性のかなりの部分がモデルのコードとして記述される。
#### 9-1 共通機能のモジュールを複数のモデルクラスniMix-in する
#### 9-2 STI（単一テーブル継承）で共通機能を基底クラスに持たせる
###### STI はコストが高い仕組みとなりやすい
- 他の類似性については継承を利用できなくなる。
- 異なるクラスのレコードを一つのテーブルに入れるため、データが一つのテーブルに集中する。データ量が多い部分に使用すると、処理速度が低下する。
- クラス名の変更をする場合、DB内notype カラムの値を変更する必要がある。
- クラスの構造に差が大きいと、DBの利用効率が悪くなる。
###### STI の利用がおすすめとなる条件
- クラス同士の関係性が、AはBの一種である、という場合。
- クラスの構造が似ている（必要なカラムに大きな差がない）
- DBにて、一つのテーブルにまとまっていると利便性が高い時。継承関係にあるクラス同士を混ぜた状態で検索したい、親子関係でつながっている他のモデルとの関係性が共通的である場合。
#### 9-3 全モデルクラスに共通の処理をApplicationRecordに書く
- ApplicationRecordは全てのモデルの基底クラスになっている。
- 利用例として、DBへの操作を常に記録するようにする、ActiveRecord::Baseの動作を上書きする、など。
#### 9-4 ApplicationRecordとモデルクラスの間に抽象的なクラスを挟む
- 特定のカテゴリのActiveRecordモデル群に共通の処理を追加したい場合がある。この場合、特定のテーブルに紐づかない抽象的なクラスを作って、任意のモデルクラス群に継承する.`abstract_class = true` を記述する。（よくわからん）

## 10-10
###### コントローラに残るコード
- アクション群の提供
- アクションの事前・事後処理であるフィルタの提供
- params に関わる処理
- セッションに関わる処理
- URL生成に関わる処理
- モデルを利用する少量のコード
- メールなど、モデル以外のロジックを扱うコード
- ビューテンプレートのハンドリングやレスポンスの動的生成、リダイレクト先の管理
#### 10-1 共通機能のモジュールを複数のコントローラクラスにMix-in する
- 共通機能を記述したモジュールを作成し、それをコントローラで include することで共通化することができる。
- コントローラ層の共通化のためのモジュールは app/controllers/concerns に配置する。
- ポイントとして、ほぼ完全に共通の処理だけを共有すること。処理の流れや画面の扱いが違うと、分岐処理などにより複雑性が上がってしまう。
###### コントローラの共通化がおすすめの条件（以下がほぼ同一であること）
- 処理で利用するインスタンス変数
- ビューテンプレート
- 主な関心事に対応するモデル
- パラメータ
- セッションへの操作
###### よくある共通化の実装例
- 承認やファイル添付、タグ付、メール送信など。モデルの種類が異なるが、処理は同じという場合。
- 共通の機能を実装する場合。利用するユーザーによりコントローラクラスが分かれている場合。
#### 10-2 基底クラスを追加して共通機能を持たせる
- アクションの追加のために、継承を用いるのは避けた方が良い。
- アクション以外の処理の共通化のために行うと良い。具体的にはprivate メソッドの実装や、フィルタの定義を行うなど。
###### コントローラクラスは以下二つに大別される
1. アクションを実装するコントローラクラス
2. 上記１に対して共通処理を提供するだけの、アクションを実装しない基底コントローラクラス
#### 10-3 Application Controller に共通機能を記述する
- すべてのコントローラはApplication Controller を継承しているため、共通性の高い処理は、Application Controllerに記述するのが良い。例えば、ログイン済みかの判定、権限の有無の判定など。

#### 10-4 第一の鍵を使わない状態で第二の鍵を使ってはいけない

## 10-11 
###### テンプレートの共通化
- パーシャルテンプレートで画面の一部を共通化する
- レイアウトで画面の大枠を共通化する
###### ビューのロジックの共通化
- カスタムヘルパーに共通処理を記述する
- Decorator パターンでモデル固有の表示ロジックを分離する。
#### 11-1 パーシャルテンプレートで画面の一部を共通化する
- _ から始まるファイルをパーシャルとして扱う。
- 埋め込み先のファイルと同じディレクトリに配置するのが一般的
- 複数のテンプレート間でパーシャルを共有する場合、`shared/****` というようにshared というディレクトリに配置する。
- 共通的なパーシャルを作る際は、構造だけでなく目的の類似性に着目すること。構造の類似性だけで共通化すると、後々の変更で共通化できなくなる可能性がある。
#### 11-2 レイアウトで画面の大枠を共通化する。
- テンプレートの外側を共通化したい場合は、layout として切り出すことができる。`app/views/layouts` に新しいテンプレートを配置するだけ。
###### 代表的な手法（？）
- 明示的な指定がない場合、コントローラ名と同じ名前のレイアウトがあれば適用される。
- コントローラのクラスメソッド `layout` でレイアウトを指定する。
- render メソッドのオプション `:layout` でレイアウトを指定する   
#### 11-3 カスタムヘルパーに共通処理を記述する
- ビューで使うユーティリティメソッドを書くための場所として、ヘルパー（カスタムヘルパー）が用意されている。複数のビューで共通的に利用したい処理をまとめて記述できる。
- デフォルトでは、すべてのコントローラから表示されるビューから参照できる。そのため、アプリケーション全体で意味が判別できるように命名する必要がある。
#### 11-4 カスタムヘルパーは小さく作る
- カスタムヘルパーを作る際は、目的に合わせて小さく作ること。グローバルに参照できるため、条件分岐を設けると簡単に複雑になってしまう。
#### 11-5 特定のモデルに依存する処理をカスタムヘルパーに含めない

## 10-12
- 複雑さに対応するため、新しい構造を作り、役割を分担させるという手法がある。考え方としては、処理やデータを意味のまとまりで分けて整理するということ。
#### 12-1 Active Model
#### 12-2 共通処理を担当するオブジェクトを別に作って連携させる
- 共通的な処理を意味のあるまとまりとしてとらえ、新しいクラス（オブジェクト）として独立させる。オブジェクトはActive Record やActive Model、 POROなど、目的に応じて使い分ける。
#### 12-3 意味のあるパラメータの集合からクラスを生み出す
#### 12-4 外部サービスのロジックを閉じ込める
#### 12-5 複数のモデルがからむ特殊処理の専門家をつくる
#### 12-6 サブリソース単位でコントローラを分割する
- resources メソッドにブロックを渡すことで簡単にアクションを定義できるが、乱用するとコントローラの見通しが悪くなる。
###### 弊害
- コントローラの関心事が何なのかわからなくなる。
- private メソッド内のアクションがどれに使われるかわかりづらくなる。
- before_action が複雑に絡み合い、用意にコードを修正できなくなる。

## 10-13
- モジュールは共通化のために強力な仕組みであるが、多用するとコードが分散し、利用元クラスから把握しづらくなるため、以下の原則を考慮するのがおすすめ
###### 13-1 構造としてわかりやすい意味をもたせる
- 意味があるまとまりをモジュールとして切り出すこと。それ以外の理由（コントローラの記述量を減らすなど）はNG
###### 13-2 利用元クラスの一部として、違和感がないか？
- モジュールのコードは、利用元クラスにて、その一部のように振舞う。そのため、モジュール全体の挙動に違和感がないかを検討すること。
###### 13-3 利用元クラスと内部データを共有していることを意識する
- モジュールで定義するメソッドの中で利用するインスタンス変数は、利用元のクラスと共用するという意識を持つこと。
######## インスタンス変数の分類の考え方
- そのむジュールで利用するつもりのインスタンス変数
モジュールで利用するインスタンス変数と重複しないよう注意すること。具体的には、モジュールで利用することが分かるような命名をすること。
- クラスの共通的なインスタンス変数
破壊的・不用意な変更を行わないこと

#### 13-4 独立的にして利用条件をわかりやすくする
- モジュールの中で依存関係があると、モジュールの扱いが難しくなる。
- そのため、モジュールは原則独立的に作ること。
- 意図的に外部のモジュールのメソッドを利用する場合、利用条件などをコントローラに明記すること。モジュール自体をinclude するなどの対策も良し。

###### 4-1 こんがらがったモジュールのリファクタリング 
- 複数のモジュールが、利用元クラスからの呼び出しの際にまとめて呼び出されているのであれば、一つのモジュールにまとめる。
- クラスの本来の機能から離れている場合、クラスとして切り出す、という手法

#### 13-5 追加部品であるという節度を守る
- モジュールは、利用するクラスに機能を付加するための部品に過ぎない。クラスの挙動を大きく変えるような処理は記述しないこと。
- クラスの挙動を大きく変える場合、新しいクラスとして切り出したり、利用者に注意喚起をすることが大事。
