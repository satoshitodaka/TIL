## 9-5 マイグレーションに注意する
#### 5-1 ロールバックできることを確認する
- マイグレーションファイルを作成する場合は、バージョンを上げる際、下げる際、両方のスキーマを記述すること。
#### 5-2 redoを習慣にする
```
bin/rails db:migrate
```
```
bin/rails db:migrate:redo
```
`redo `を実行することにより、バージョンを下げる時に不具合が起きないか確認できる。
#### 5-3 完全なロールバックができないとき
- 不可逆的な変更のマイグレーションをロールバックする（完全なロールバックが不可）場合
###### ロールバックを行う。
- カラムは復活させ、データについてはなにもしない。または仮の値を入れておく。
###### ロールバックを禁止する。
- raise deActiveRecord::IrreversibileMigration エラーを発生させ、ロールバックによりデータが壊れるのを防ぐ
###### ロールバックはするば、実際は何もしない。
- 下げる処理をあえて記述せず、コメントで意図を示す。

#### 5-4 過去のマイグレーションファイルの変更は慎重に行う。
- 過去のマイグレーションファイルの操作はチームに混乱をもたらすため、極力新しいマイグレーションファイルを作成すること。
- きれいなマイグレーションファイルを追求しないこと。

#### 5-5 マイグレーションファイルが多くなってきたら
- Squasher というgem を使えば、任意の期間のマイグレーションファイルをまとめることができる。

#### 5-6 直接DBを変更したら、必ずマイグレーションファイルを追加すること。
- 手作業でDBの変更を行わないことが理想。
- 手作業でDBを変更した場合、対応するマイグレーションファイルを作成すること（イメージは湧かないが。。）

#### 5-7 データメンテナンス
- 運用中のアプリケーションのDBには様々なデータが保存されていて、この状態でマイグレーションを走らせる場合は、既存データへの影響を考慮する必要がある。
###### 7-1 アプリケーションコードの参照はなるべく避ける。
- アプリケーションコードは開発とともに変化する可能性があるため、直接参照することは避けること。
- ActiveRecordをマイグレーションで安全に利用するために、マイグレーションファイルの中で、空のモデルクラスを定義して使う。アプリケーションコードに依存しないため,`ActiveRecord::Base` で継承すること。
###### 7-2 一度にインスタンス化するレコード数には気を付ける。
- インスタンスを`all` で取得すると、一度に大量のメモリを消費してしまう。そのため、1000件単位で分割して取得し、ブロック内の処理を行う`find_each`をつかうこと。 
###### 7-3 失敗時には例外を発生させる。
- マイグレーションに失敗した時は、ロールバックするのが望ましい。処理で例外が発生すると、失敗したとみなされロールバックされる。
- 処理が失敗した時に例外を発生させるためには、!がついたメソッドをつかうのが望ましい。
- `save!``create!``update!``destroy! `など
###### 7-4 スキーマキャッシュの存在を意識する。
- ActiveRecord には、一度読み込んだスキーマをキャッシュする機構が備わっている。これは、テーブルのスキーマを毎回問い合わせすることによるパフォーマンスの低下を防ぐ機能。
- この問題を回避するために、手動でスキーマキャッシュを削除する必要がある。
- マイグレーションでActive Record を使う時は、その前に必ずスキーマキャッシュを更新する習慣を持つこと。
```
Order,reset_column_information
Order.find_each_do |order|
end
```
###### スキーマキャッシュの特徴
- モデルインスタンスの作成時、Active Record はスキーマをキャッシュする。
- テーブル単位でキャッシュし、同一コネククションでキャッシュを利用する。
- テーブルの変更（カラムの追加、変更、削除）は自動でスキーマキャッシュに反映されない。
