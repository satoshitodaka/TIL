# もう怖くないGit！チーム開発で必要なGitを完全マスター

## 2 Gitは何のために使うのか？
ファイルのバージョンを管理するために使う。<br>
ファイルのバージョン管理をしないと、更新状況がわからず混乱する。<br>
元の状態を把握し、誰が、いつ、何を変更したかがわかる。

## 3 Gitの歴史
Linuxカーネル開発で利用するバージョン管理システムがライセンスの都合で使用できなくなったため、自分で開発することにした。<br>
2005年ごろにGitの原型となるプログラムが作成された。<br>
開発を迅速に行うため、以下が重視されている。<br>
スピード、シンプルな設計、ブランチが並列で開発可能、大規模プロジェクトを効率的に扱える。

## 4 GitとGithubとは？
- Gitはバージョン管理のためのツール
- Githubは、Gitのオンラインホスティングサービス。<br>
- プルリクエストなどの機能を使い、複数人で開発ができる。<br>
- 世界中のチームがGIthub上で開発している。

## 13 Gitの基本的な仕組み
- Gitはスナップショットを記録している。<br>
ある時点のファイルを丸ごと保存し、更新があれば都度丸ごと保存する。<br>
なぜバージョン管理をするか？コミットを辿ることで、以前の状態に戻せる。<br>
コミットは直前のコミットを記憶しており、最古のコミットまで辿ることができる。

## 14 Gitの操作の流れ
- 自分の操作をアップする場合<br>
自分のワークツリーからスナップショットをローカルリポジトリに記録、Githubにアップ。<br>
- 他人の操作をプルする場合<br>
GithubからローカルリポジトリにDL、それをワークツリーに反映させる。<br>

####  ローカルは3つのエリアに分かれている。
- ワークツリーは手元の作業場、ファイルを変更する場所<br>
- ステージはコミットの準備をする場所、仮置き場のような場所<br>
- リポジトリはスナップショットを記録する場所

## 15 Gitはどのようにデータを管理しているのか
####  Gitのデータ構造は？
- Git add<br>
レポジトリに作成したファイルの圧縮ファイルを作成する。（文字列をハッシュ関数で暗号化したもの）<br>
ステージ上に、圧縮ファイルと作成したファイルを紐付けるインデックスを作成する。<br>
- Git commit<br>
ステージに作成したインデックスを元に、レポジトリにツリー（ファイル構成を記録するもの）を作成する<br>
次に、ツリーに対してコミットという情報を作成する。コミットには、ツリーの情報、作成者、日付とメッセージが記録される。

## 16 Gitのデータ管理は？
####  ファイルを新規追加した場合は？
- コミットを作成する際、親コミットを登録する仕組みとなっており、これにより前のコミットを辿れる。（見出しと説明が一致しない？）
####  ファイルを変更したら
- Git addの圧縮ファイル作成は、変更があったファイルのみ行われる（未修正ファイルは行われない）<br>
ステージ上のインデックスは、前回のインデックス情報を上書きする形で記録される。<br>
- Git commitでは、変更内容を反映したツリーを作成、スナップショットを保存する。<br>
コミットには作成したツリーと、変更前の親コミット情報が記録されるので、変更の履歴を辿ることができる。

####  まとめ
- Gitはデータ保存時に、リポジトリに「圧縮ファイル」「ツリー」「コミット」ファイルを作成する。
- コミットは親コミットが記録されており、変更履歴を辿ることができる。
- Gitの本質は、データを圧縮しスナップショットで保存すること。
- これらのデータに対してGitコマンドを用いると、様々なデータの操作ができる。

## 17 Gitのはじめ方
- まず最初にgit initを実行する。<br>
→.gitディレクトリが作成される。これにはgitに必要なほとんど全てのファイルが含まれる。

## 18 Github上のプロジェクトから始める
- Gitレポジトリのコピーを作成する。（git clone URL）<br>
このコマンドにより、作業ツリーとgitディレクトリがローカルにコピーされる。

## 19 変更をステージに追加する。
- Git add ファイル名を指定する。（またはgit add . 、Git add ディレクトリ 名）
- ステージは、ワークツリーでの一部の変更だけを記録する場合に有意。

## 21 変更を記録する。（コミット）
- Git commitでコミットできる。このコマンドではエディタが起動するので、詳細を登録できる。
- -mはエディタを起動せずにコメントを残せる。
- -vは変更内容を確認できる。
- コミットメッセージはわかりやすく書く。<br>
簡単に書く場合は１行で、正式に書く場合は、用件に１行、理由に１行を入力する。

## 22 現在の状況を確認する。
- Git status<br>
ワークツリーとステージ、ステージとリポジトリの間で変更があれば表示する。

## 23 何を変更したかを確認する。
- Git diff<br>
コマンドの後にファイル名を付ければ、特定のファイルの変更内容を確認できる。<br>
--stagedをつければ、git addした後の変更分を確認できる。（コミットしていない内容）

## 24 変更履歴を確認する。
- Git log<br>
Git log --oneline 1行で表示する<br>
Git log -p ファイル名 ファイルの変更差分を表示する。　ファイル名は省略可能<br>
Git log -n コミット数 表示するコミット数を表示する。

## 25 ファイルの削除を記録する。
- ファイルごと削除する<br>
Git rm ファイル名<br>
Git rm -r ディレクトリ名<br>
- ファイルを残したいとき<br>
Git rm --cashed ファイル名

## 26 ファイルの移動を記録する。
- Git rm 旧ファイル名 新ファイル名<br>
これは以下と同じ挙動をする。<br>
Mv 旧ファイル 新ファイル<br>
Git rm 旧ファイル<br>
Git add 新ファイル<br>

## 27 Githubにプッシュする
- Git push origin master

## 28 Githubの画面を確認する
- Raw データの生ファイルで、コピペに便利
- Blame 責任者という意味で、ファイルのコミットの履歴を確認できる。

## 29 コマンドにエイリアスをつける。
以下の設定をすることで、コマンドの省略形を登録できる。--globalコマンドによりPC全体に適用される。<br>
- Git config --global alias.ci commit
- Git config --global alias.st status
- Git config --global alias.br branch
- Git config --global alias.co checkout

## 30 バージョン管理したくないファイルを無視する。
- バージョン管理したくないファイルは管理から外す（パスワード管理、自動生成されるファイルなど）
- .gitignoreファイルに指定する。<br>
ファイル名 指定したファイルを除外<br>
/root.html ルートディレクトリを指定<br>
ディレクトリ名/ ディレクトリ以下を除外<br>
/*/*.css /以外の文字列にマッチするファイルを除外

## セクション4
## 31 ファイルへの変更を取り消す
- Git checkout<br>
Git checkout --ファイル名<br>
Git checkout --ディレクトリ名<br>
Git checkout --.　全変更を取り消す<br>
--をつけるのは、ブランチ名とファイル名が被った際にどちらを指定しているか（ファイル名を指定ということ）をgitに示すため

## 32 ステージした変更を取り消す
- Git reset HEAD<br>
上記コマンドの後に以下を指定すると、ステージでの変更を取り消す対象を指定できる。<br>
※ワークツリーの変更は取り消せないので、ワークツリーを戻す場合はgit chekoutコマンドを使うこと。v
Git reset HEAD ファイル名<br>
Git reset HEAD ディレクトリ名<br>
Git reset HEAD .　変更を全て取り消す<br>
HEADは、最新のコミットの情報を指す。

## 33 直前のコミットをやり直す
- Git commit --amend(amendとは、やり直すという意味）<br>
※リモートにpushした後はamendしたらNG

## セクション5
## 34 リモートリポジトリの情報を確認する。
- Git remote<br>
登録されているリモートリポジトリ名を表示する。-vを使うと、URLが表示される。

## 35 リモートリポジトリを追加する。
- リモートリポジトリは複数登録することができる。

## 36 リモートから取得する。（fetch）
- リモートからの取得には2種類ある。fetchとpull<br>
リモートの内容をローカルリポジトリに持ってくる操作（マージは行わない）

## 37 リモートから取得する（pull）
- Git pull origin master　※origin master は省略可能。<br>
Git fetch origin masterとgit merge origin/masterを同時に実行するコマンド

## 38 フェッチをプルを使い分ける。
- Git pullは、今現在いるローカルのワークツリーにマージするため<br>
ブランチを指定する意図があった場合は注意が必要。（違うブランチに移動する必要あり）<br>
- 基本はフェッチがおすすめ

## 39 リモートの情報を詳しく知る。
- Git remote show リモート名　で、リモートの詳細情報を取得できる。<br>
フェッチとプッシュのURL、リモートブランチ、git pullの挙動、git pushの挙動

## 40 リモートを削除、変更する場合
- 変更　Git remote rename 旧リモート名 新リモート名
- 削除　Git remote rm リモート名

## セクション6
## 41 ブランチとは
- 並行して複数の機能を開発するための機能

## 42 ブランチの仕組み
- gitにおいて、コミットがスナップショットを記録し、それが時系列に連なっている。<br>
ブランチとはこのコミットを指したポインタの事。<br>
HEADという言葉があり、これは今作業しているブランチをさす。（作業中ブランチのポインターに過ぎない）<br>
コミットした場合、ブランチが指すコミットファイルが最新のものに変わる。<br>

## 43 新しいブランチを作成する
- Git branch ブランチ名<br>
このコマンドでブランチが作成されるが、切り替わらないので注意。
- Git branch<br>
全てのブランチを表示する。-aコマンドではリモートも含めて全てを表示する。

## 44 ブランチを切り替える
- Git checkout 既存のブランチ名
- Git checkout -b 新ブランチ名 新規作成と切り替えを同時に行う。
- なぜブランチを切り替えるのか？分岐して別の作業をするため。

## 45 変更をマージする
他の人の変更を取り込む事<br>
- Git merge ブランチ名
- Git merge リモート名/ブランチ名

マージは3種類ある。
- ブランチが枝分かれしていなかった場合<br>
Fast Foward：早送りになるマージ。masterのポインタが動くだけ。
- 通常のマージ<br>
Auto Merge：枝分かれしている場合にマージコミットという新しいコミットを作る。

## 46 コンフリクトを解決する。
- 同じ行に対して複数の人が異なる編集を行った場合。<br>
→どちらの内容をマージすれば良いかgitは判断できず、コンフリクトが発生する。
- コンフリクトの状況はgit statusコマンドで確認する。
- コンフリクトが発生した場合は、HEAD側でファイルを編集する。<br>
コンフリクトの内容が自動で追記されているので、任意の内容に変更し、再度コミットする。

## 47 コンフリクトが起きないようにするには
#### 運用ルール
- 複数人で同じファイルを変更しない。
- pullやmergeをする前に、変更中の状態を無くしておく。（commitやstashする）
- pullする場合は、pullするブランチに移動してからpullする。
- コンフリクトしても慌てない。

## 48 ブランチ名の変更、ブランチの削除
- HEADブランチ名を変更する。<br>
Git branch -m 新しいブランチ名　-mはmoveの略
- ブランチを削除する<br>
Git branch -d ブランチ名<br>
※-dはマスターにマージしていないと削除しない。-Dはマスターにマージしていないブランチを強制削除

## 49 ブランチを利用した開発流れ
- masteはリリース用ブランチ、開発はトピックブランチで行う。<br>
トピックブランチで開発が終われば、masterブランチにマージする。

## 50 リモートブランチについて
- リモートブランチとは、リモートのブランチの状態へのポインタ

## 51 プルリクエストの流れ
- 自分の変更したコードをリポジトリに取り込む依頼をする機能<br>
必ず他人のレビューを経て取り込むようにする必要がある。そのための仕組みがプルリク
- コードレビューは、依頼する人を指定できる（チーム開発の場合）」
- ブランチをマージした後は、ブランチは削除する事。

## 52 Github Flowのながれ
Github Flowとは、masterブランチ→トピックブランチ作成→開発・コミット→プルリクエスト→レビュー→masterにマージ<br>
#### ポイント
- masterブランチは常にデプロイできる状態に保つ。
- 新しい開発はmasterブランチから新しいトピックブランチを作成する。
- 作成したブランチで作業しコミットする。
- 定期的にpushする（これにより、開発の進捗をチームで共有できる）
- masterにマージするためにプルリクエストを使う。
- 必ずレビューを受ける。
- masterブランチにマージしたらすぐにデプロイする。<br>
→テストとデプロイは自動化する事。

## 53 GithubFlowの実践

## 54 リベースする
リベースとは、変更を統合する際に履歴を整えること。
- Git rebase 親コミットとしたい登録したいブランチ名

## 55 リベースのNG事項
- GithubにプッシュしたコミットをリベースすることはNG

## 55 リベースとマージの使い分け
- マージの特徴<br>
コンフリクトの解決が容易。マージコミットがたくさんあると履歴が複雑化する。<br>
→履歴を残したい場合に使う。
- リベースの特徴<br>
履歴をきれいに保つことができる。コンフリクトの解消が若干面倒<br>
→履歴をきれいに保ちたい時に使う。
- マージとリベースのコンフリクトの違い<br>
コミットが複数ある場合、マージは一度だけ、リベースはコミット毎にコンフリクトが発生する。
- 使い分け<br>
プッシュしていないローカルの変更はリベースを使う。<br>
リモートリポジトリにプッシュした後はマージを使う。<br>
コンフリクトしそうな場合はマージを使う。（Githubでチームの開発の進捗を伺う、Githubの警告から判断する）

## 56 プルの設定をリベース型に変更する。
- プルのマージ型<br>
マージコミットの記録が残るため、残したい場合に使う。<br>
- プルのリベース型（git pull --rebase origin master）<br>
マージコミットの記録が残らないため、残したくない（単にプルしたいだけ）場合に使うと良い。

## 57 リベースで履歴を書き換える
- コミットをきれいに整えてpushする。
- 一つのコミットをやり直す場合はgit commit --amendを使う。複数のコミットを対象とする場合はrebaseを使う。
- 複数のコミットをやり直す。<br>
Git rebase -I コミットID（またはHEAD~3←HEADから3つ)-iはインタラクティブ（対話的）
#### 親コミットの指定方法<br>
- ~チルダ　親コミットを指す
- ^キャレット　マージした場合の親コミットを指す。
#### 手順
①Git rebase -I コミット名<br>
指定したコミット以降にて、対話的リベースモードに入る。<br>
②修正したいコミットをeditに変更し、コミットエディタを終了する。<br>
③コミット毎にリベースするが、editで処理が止まる。<br>
④ファイルを修正、addし、git commit --amendをする。<br>
⑤git rebase --continueを実行する。<br>
⑥pickは内容をそのまま適用、HEADにいたると終了する。

## 58 リベースで履歴を書き換える②
コミットの並び替えと削除、まとめる、分割する。<br>
- コミットの削除<br>
Git rebase -iでコミットエディタを起動する。<br>
削除したいコミットの行を削除する。<br>
- コミットの並び替え<br>
Git rebase -iでコミットエディタを起動する。<br>
並び替えたいコミットを入れ替える。※新しいものが下になる。<br>
- コミットをまとめる<br>
Git rebase -iでコミットエディタを起動する。<br>
まとめたいコミットのpickをsquashに修正する。<br>
- コミットを分割する。<br>
Git rebase -iでコミットエディタを起動する。<br>
分割したいコミットのpickをeditに修正する<br>
Git reset 戻したいHEADコミット（コミットを取り消す）<br>
Addとコミットを分割したい単位毎にやり直す。<br>
Git rebase --continue<br>

## 59 タグの一覧を表示する。
タグとは、コミットを参照しやすくするためにわかりやすい名前をつけるもの。リリースポイントによく使われる。
- タグの一覧を表示する。<br>
Git tag -lタグで文字列を指定すると、文字列を含むタグを表示する。

## 60 タグを作成する。
タグには2種類ある。注釈付版（annotated）と軽量版（lightweight）がある。<br>
情報量が多いため、注釈付きタグを使うのがおすすめ<br>
- 注釈付版タグ<br>
Git tag -a タグ名 -m "メッセージ"<br>
※-aオプションはannotatedの略、-mはメッセージ（付けないと遷移する）<br>
- 軽量版タグ<br>
Git tag タグ名
- 過去のコミットに後からタグをつける<br>
Git tag タグ名 コミット名
- タグのデータを表示する<br>
Git show タグ名

## 61 タグをリモートリポジトリに送信する。<br>
Git push コマンドだけではタグは送信されない。
- 個別にタグを送信する。<br>
Git push リモート名　タグ名
- タグを一斉に送信する。<br>
Git push origin --tags

## 63 作業を一時待避する
- Git stash (save)※saveは省略可能。stashは隠すという意味。<br>
→編集中の内容をstashと呼ばれる場所に一時的に退避させる。

## 64 避難した作業を確認する
- Git stash list<br>
スタッシュした作業のリストを確認する。

## 65 避難した作業を復元する。
- 最新の作業を復元する<br>
Git stash apply
- ステージの状況も復元する。<br>
Git stash apply --index　
- 特定の作業を復元する。<br>
Git stash apply スタッシュ名（stash@{1}など）

## 66 避難した作業を削除する
- git stash drop
- 特定の作業を削除する場合<br>
Git stash drop スタッシュ名<br>
- 全作業を削除する。

## 補足
https://shinmedia20.com/git-remote-tracking
#### リモートブランチと追跡ブランチは別物
- リモート追跡ブランチは、　別名リモートトラッキングブランチという。
- リモートブランチを追跡しているブランチで、ローカルリポジトリの中に存在する。
![remote_tracking_branch](https://shinmedia20.com/wp-content/uploads/2018/10/e73d5478e83e53c502f48b27e095b8b4.png)
- 画像の通り、ローカルブランチはリモート追跡ブランチを参照しており、リモート追跡ブランチはリモートブランチを参照する。
- git fetchはリモートブランチからリモート追跡ブランチにとってくるコマンド、という事になる。
