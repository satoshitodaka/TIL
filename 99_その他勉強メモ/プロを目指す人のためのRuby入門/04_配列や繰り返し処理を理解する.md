# 4 配列や繰り返し処理を理解する
## 4.1

## 4.2
### 4.2.1
- 添字を指定して値を代入すると、指定した要素を変更することができる。
- 配列の元の大きさよりも大きな添字を指定すると、間の値はnilで埋められる。
- `<<`を使うと、配列の最後に要素を追加することができる。
- 配列内の特定の要素を削除する場合、delete_atメソッドを使う。

### 4.2.2
- 変数の多重代入と同様に、配列も多重代入することができる。
```rb
#配列を使って多重代入する
a, b = [1, 2]
a #=> 1
b #=> 2

#右辺の数が少ない場合はnilが入る
c, d = [10]
c #=> 10
d #=> nil

#右辺の数が多い場合ははみ出した値が切り捨てられる
e, f = [100, 200, 300]
e #=> 100
f #=> 200
```
- 多重代入を使うとコードがスッキリするケースがある。
  - 何らかの配列を返すメソッドに対して使うと有効そう。
```rb
# divmodは商と余りを配列で返す
14.divmod(3) #=>[4,2]

#戻り値を配列のまま受け取る
quo_rem = 14.divmod(3)
"商=#{quo_rem[0]}, 余り=#{quo_rem[1]}" #=> "商=4,余り=2"

#多重代入で別々の変数として受け取る
quotient, remainder = 14.divmod(3)
"商=#{quotient}, 余り=#{remainder}" #=> "商=4,余り=2"
```

## 4.3
- ブロックとは、メソッドの引数として渡すことができる処理の塊
### 4.3.1
### 4.3.2
- Rubyではfor文はほとんど使わず、eachメソッドを使うことが多い。
- 配列に対してeachメソッドを使うと、eachメソッドは配列の要素を順番に取り出し、ブロックに渡す。要素に対する具体的な処理は、ブロック内に記述することでこれが実行される。

### 4.3.3
- 要件を問わず共通する処理をメソッドで実行する（1個ずつ取り出すeachメソッドなど）
- 要件によって異なる処理はブロックで実行する。

### 4.3.4
- ブロックパラメータの文字列は、任意の文字列を使用することができる。
- ブロックパラメータを使わない場合、ブロックパラメータ自体を省略することができる。
- ブロック内で設定したローカル変数は、ブロックの中でのみ使用できる。ブロックの外で設定したローカル変数は、ブロックの外と中どちらでも使用できる。
- ブロックの外で設定したローカル変数と、ブロックパラメータが同一である場合、ブロックパラメータの値が優先して参照され、ローカル変数は参照できなくなる。このような、名前の重複により変数やメソッドを参照できなくなることをシャドーイングという。読み手を混乱させ、思わぬ不具合に繋がるので、同じ名前を使うことは避けること。

### 4.3.5
- ブロックは改行しなくても動作する。ただし読みづらい。
```rb
numbers = [1,2,3,4]
sum = 0
#ブロックをあえて改行せずに書く
numbers.each do |n| sum += n end
```
- do...endで囲む以外に、{}で囲んでもブロックは動作する。
```rb
numbers = [1,2,3,4]
sum = 0
#do...endの代わりに{}を使う
numbers.each { |n| sum += n }
sum #=>10
```
- {}で囲んだブロックは改行することもできる。
```rb
numbers = [1,2,3,4]
sum = 0
#{}でブロックを作り、なおかつ改行を入れる
numbers.each { |n|
  sum += n
}
sum #=>10
```
- do...endと{}の使い分けは明確に決まっているわけではないが、概ね下記の通り
  - 改行を含む長いブロックを書く場合はdo...end
  - 1行にコンパクトに描きたい場合は{}

## 4.4
### 4.4.1
- mapメソッドは、各要素を順にブロックに渡して、ブロック内の評価を新しい配列に格納する処理をする。
- エイリアスメソッドはcollect
- 空の配列を用意し、ブロック内で処理した結果を空の配列に格納する処理は、mapメソッドを使うと良い。

### 4.4.2
- selectメソッドは、各要素をブロックに渡し、評価した結果が真の要素を集めた配列を返す。エイリアスメソッドはfind_all
- rejectメソッドは、各要素をブロックに渡し、評価した結果が偽の要素を集めた配列を返す

### 4.4.3
- find/detectメソッドは、ブロックの戻り値が真となった最初の要素を返す

### 4.4.4
- sumメソッドは、要素の合計を返す
  - 初期値は0だが、引数に任意の数字を渡すことで、任意の初期値を指定できる。
- sumメソッドに文字列の配列を渡すと、結合した文字列を返す

- 同様の働きをするメソッドにjoinがある。
  - joinも、sumと同様に文字や数値を渡すと、結合した文字列を返す。
  - joinは、第一引数を指定することで、任意の区切り文字を設定できる。
  - シンプルな結合であればjoinの方がわかりやすいと言える。sumは、空文字以外の初期値（もしくは先頭文字）を指定したり、ブロック内で文字列を加工する場合に使うと良い。
```rb
chars = ['a', 'b', 'c']
# 先頭に'>'を付け、各要素を大文字にして連結する
chars.sum('>'){ |c| c.upcase }#=>">ABC"
```

### 4.4.5
- ブロックを使うメソッドは、条件によってはかなり簡潔に書くことができる。
- ブロックに対して、`&:メソッド名`を渡す。これは、以下の条件で使える。
  - ブロックパラメータが一つだけ
  - ブロックの中で呼び出すメソッドには引数がない
  - ブロックの中で、ブロックパラメータにメソッドを1回呼び出す以外の処理がない
```rb
# このコードは、
['ruby','java','python'].map{|s|s.upcase} #=>["RUBY","JAVA","PYTHON"]
# こう書き換えられる
['ruby','java','python'].map(&:upcase)  #=>["RUBY","JAVA","PYTHON"]

# このコードは、
[1,2,3,4,5,6].select{|n|n.odd?} #=>[1,3,5]
# こう書き換えられる
[1,2,3,4,5,6].select(&:odd?)#=>[1,3,5]
```
- 上記の書き換えについて、以下の状況では使えない。
  - ブロックの中で、メソッドではなく演算子を使っている。
  - ブロックの中で呼び出すメソッドに引数を渡している。
  - ブロックの中で複数の文を実行している。

## 4.5
- rubyには値の範囲を表すRangeオブジェクトがある。
```rb
最初の値..最後の値（最後の値を含む）
最初の値...最後の値（最後の値を含まない）
```
- 範囲オブジェクトを変数に入れず、直接メソッドを呼び出す場合は()を付けること。`..`や`...`は優先順が低いため。
```rb
#　()で囲まずにメソッドを呼び出すとエラーになる
1..5.include?(1) #=> undefinedmethod`include?'for5:Integer(NoMethodError)
# 上記は1..(5.include?(1))と同じ内容となる。

#　()で囲めばエラーにならない
(1..5).include?(1) #=> true
. 
```

### 4.5.1
- 配列に対して、添字でなく範囲オブジェクトを渡すと、指定した範囲の要素の値を取得することができる。

### 4.5.2
- n以上m以下、n以上m未満の判定をしたい場合、範囲オブジェクトを使うと簡単に書ける。
```rb
# 不等号を使う場合
def liquid?(temperature)
  #0度以上100度未満であれば液体、と判定したい
  0 <= temperature && temperature < 100
end
liquid?(1) #=> false
liquid?(0) #=> true
liquid?(99) #=> true
liquid?(100) #=> false

#　範囲オブジェクトを使う場合
def　liquid?(temperature)
  (0...100).include?(temperature)
end
liquid?(1)　#=>　false
liquid?(0)　#=>　true
liquid?(99)　#=>　true
liquid?(100)　#=>　false
```

### 4.5.3
- case文のwhen節で範囲オブジェクトを指定することができる。
```rb
def charge(age)
  case  age
  # 0歳から5歳までの場合
  when 0..5
    0
  # 6歳から12歳までの場合
  when 6..12
    300
  # 13歳から18歳までの場合
  when 13..18
    600
  # それ以外の場合
  else
    1000
  end
end
charge(3) #=> 0
charge(12) #=> 300
charge(16) #=> 600
charge(25) #=> 1000
```

### 4.5.4
- 範囲オブジェクトに対してto_aメソッドを使うと、値が連続する配列を返す
- []の中に、`*`と範囲オブジェクトを置くと、配列を返してくれる。
```rb
[*1..5] #=> [1,2,3,4,5]
[*1...5] #=> [1,2,3,4]
```

### 4.5.5
- 範囲オブジェクトを配列にすると、繰り返し処理を行うことができる。
- 配列にしなくても、範囲オブジェクトに対して直接繰り返し処理を実行できる。

## 4.6
実際にテストを書く課題

## 4.7
### 4.7.1
- 配列において、添字を２つ使うと、添字の位置と取得する長さを指定することができる。
```rb
配列[位置, 取得する長さ]
```
- value_atを使うと、取得したい要素の添字を複数指定できる。
```rb
a = [1, 2, 3, 4, 5]
a.values_at(0, 2, 4)  #=>[1,3,5]
```
- 添字に「配列の長さ-1」を指定すると、配列の最後の要素を取得できる。
- これについて、Rubyでは添字に負の値を使うことができる。−1を指定すれば配列の最後の要素、−２を指定すれば配列の最後から2番目を取得できる。

### 4.7.2
- 配列の値を更新する場合、負の添字を使うことができるが、元の配列の大きさを超える負の添字は使用できない（エラーが発生する）
- 指定した値に一致する要素を削除したい場合、deleteメソッドを使う。
  - deleteメソッドの戻り値は削除した値となる。

### 4.7.3
- 二つの配列を結合したい場合、concatメソッドか+演算子を使う。
  - concatメソッドを使って配列を連結する場合、元の配列が変更される（破壊的な変更）
  - +演算子を使うと、元々の配列は変更せず、新しい配列を作成する。（非破壊的な変更）
- 基本的には、+演算子での結合が望ましい。破壊的変更を行うと、何らかの不具合が発生する可能性がある。

### 4.7.4
- 配列に`|`を使うと和集合を求めることができる。
```rb
a=[1,2,3]
b=[3,4,5]
a | b #=> [1,2,3,4,5]
```

- 配列に`-`を使うと差集合を求めることができ、左辺から右辺に含まれる要素を取り除く
```rb
a=[1,2,3]
b=[3,4,5]
a - b #=>[1,2]
```
- 配列に`&`を使うと積集合を求めることができ、左辺から右辺に共通する要素を返す
```rb
a = [1,2,3]
b = [3,4,5]
a & b #=> [3]
```
- いずれの演算子も非破壊的で、元の配列は破壊しない

### 4.7.5
- 配列に多重代入する際にはみ出た値は切り捨てられるが、この際に左辺の変数に`*`を付けると、残りの全要素を配列として受け取ることができる。
```rb
e, *f = 100, 200, 300
e #=> 100
f #=> [200,300]
```
- 残りの要素を無視する場合、`*`に続く変数を省略するか、または`*変数`を省略する。
```rb
#100だけeに格納して、残りの要素は無視する
e,　*　=　100,　200,　300
e　#=>100

# * を省略して200と300を無視する（通常の多重代入とあまり変わらない）
e, = 100, 200, 300
e #=> 100
```
- 配列の中間にある要素のうち、余った文を全て任意の変数に格納することができる。
```rb
a, *b, c, d = 1, 2, 3, 4, 5
a #=> 1
b #=> [2, 3]
c #=> 4
d #=> 5
```
- `*`がついた変数には、間に挟まれた残りの全要素が格納されるため、対応する値がない場合は空の配列となる。
```rb
#1がa、2がc、3がdに対応する。右辺に残りの要素はなくなったのでbは空の配列になる
a, *b, c, d = 1, 2, 3
a #=> 1
b #=> []
c #=> 2
d #=> 3
```

### 4.7.6
- pushメソッドで配列に複数の要素を追加することができる。この場合、変数をそのまま追加すると、要素に配列のまま追加されてしまう。
```rb
a = []
b = [2, 3]
a.push(1)
# 配列をそのまま追加する（a.push([2,3])と同じ）
a.push(b)
a #=> [1, [2, 3]]
```
- 上記の状況で、配列を展開して複数の要素として追加したい場合、配列の前に`*`（splat演算子）を追加する。
```rb
a = []
b = [2, 3]
a.push(1)
#配列を*付きで追加する（a.push(2,3)と同じ）
a.push(*b)
a #=> [1, 2, 3]
```
- 上記と似た使い方で、case文のwhen節にて、配列を渡して複数の条件を指定することができる。
```rb
jp = ['japan', '日本']
country = '日本'
case country
#*により配列が展開され、when'japan','日本'と書いたのと同じ意味になる
when *jp
  'こんにちは'
end
#=>"こんにちは"
```

### 4.7.7
- 個数に制限がない引数のことを可変長引数という。
- 自分で定義するメソッドで可変長引数を使う場合、引数の前に`*`をつける。
```rb
def メソッド名(引数1, 引数2, *可変長引数)
  #メソッドの処理end
end
```
- 可変長引数として受け取った引数は、配列として扱うことができる。
  - これについて、多重代入の考えと似ていて、配列として引数に渡す場合は、その引数は「仮引数」となる。
- 可変長引数について、変数の割り当てから漏れた引数を配列に取り込むため、rest引数（残り物）と呼ばれることがある。

### 4.7.8
- []の中に配列(または配列を持つ変数)を入れると、かっこが重複する。
- 配列（またはその変数）の前に`*`を置くと、括弧の重複を避けることができる。
```rb
a = [1, 2, 3]
# []の中にそのまま配列を置くと、入れ子になった配列（ネストした配列）になる
[a] #=> [[1,2,3]]
# *付きで配列を置くと、展開されて別々の要素になる
[*a] #=> [1, 2, 3]
```
- これを使うと、別の配列を要素とする新しい配列を作成することができる。
```rb
a = [1, 2, 3]
[1, 0, *a, 4, 5]
#=> [1,0,1,2,3,4,5]
```

### 4.7.9
- 配列の値を比較する場合、演算子`==`が使える。

### 4.7.10
- ％記法を使うと、配列を簡潔に書くことができる。
  - カンマではなく、空白文字や改行文字を区切り文字とすることができる。
  - `'`や`"`で文字列を囲む必要がなくなるため、結果的に短いコードで済む。

### 4.7.11
- 文字列を分解して配列にすることができる。
  - charsメソッドは、一文字一文字を区切って配列を返す。
  - splitメソッドは、区切り文字で区切って配列を返す。

### 4.7.12
- `Array.new`で配列を作成することができる。
  - 第一引数では要素数を指定できる。デフォルト値はnil
  - 第二引数ではデフォルト値を指定できる。
  - ブロックを使って配列の値を設定することができる。
```rb
# 要素数が10で、1,2,3,1,2,3...と繰り返す配列を作る
a = Array.new(10){|n| n % 3 + 1}
a #=> [1,2,3,1,2,3,1,2,3,1] 
```

### 4.7.13
- 第二引数に文字列を指定してデフォルト値を設定する場合、各要素は一つのオブジェクトを参照する状態となる。そのため、任意の要素を上書きしようとすると、配列全ての要素が書き換わってしまう。
```rb
# 要素が5つで'default'をデフォルト値とする配列を作成する
a = Array.new(5,'default')
a #=> ["default", "default", "default", "default", "default"]
# 1番目の要素を取得する
str = a[0]
str #=> "default"
# 1番目の要素を大文字に変換する（破壊的変更）
str.upcase!
str #=>"DEFAULT"
#配列の要素すべてが大文字に変わってしまった！
a #=> ["DEFAULT", "DEFAULT", "DEFAULT", "DEFAULT", "DEFAULT"]
```

- この問題を回避するために、引数ではなくブロックでデフォルト値を渡すようにする。
  - ブロックの中で新しい文字列が生成されるため、配列の各要素は別々のオブジェクトを参照するようになる。
```rb
# ブロックを使って、ブロックの戻り値をデフォルト値とする
# （ブロックパラメータには添え字が渡されるが、ここでは使わないのでブロックパラメータを省略）
a = Array.new(5){'default'}
a #=>["default","default","default","default","default"]

# 1番目の要素を取得する
str = a[0]
str #=> "default"

# 1番目の要素を大文字に変換する（破壊的変更）
str.upcase!
str #=> "DEFAULT"

# 1番目の要素だけが大文字になり、ほかは変わらない
a #=> ["DEFAULT","default","default","default","default"]
```

### 4.7.14
- ブロックを使って要素を生成すれば問題が発生しないか、というとそうでもない。
- ミューダブル（変更可能な）とイミューダブル（変更が不可能な）という考えがある。
- ミューダブルなオブジェクトは、破壊的な変更が可能のため、配列の要素が同じオブジェクトを参照している場合、全ての要素に値の変更が適用されてしまう。
- イミューダブルなオブジェクトは破壊的な変更が適用されないため、ブロックを使わずにデフォルト値を設定しても、破壊的な変更が適用されない。
- イミューダブルなクラスや値は以下の通り
  - 数値　Integer Float
  - シンボル　Symbol
  - trueやfalse True/False
  - nil
  - 範囲　Range
- イミューダブルなオブジェクトは、freezeメソッドにより変更を禁止することができる。

### Column
- Stringクラスの文字列であっても、配列と同様に値（配列でいう要素）を操作できる。
```rb
a = 'abcde'
# 3文字目を取得する
a[2] #=> "c"
# 2文字目から3文字分を取得する
a[1,3] #=> "bcd"
# 最後の1文字を取得する
a[-1] #=> "e"
# 1文字目を"X"に置き換える
a[0] = 'X'
a #=> "Xbcde"
# 2文字目から3文字分を"Y"で置き換える
a[1,3]='Y'
a #=> "XYe"
# 末尾に"PQR"を連結する
a << 'PQR'
a #=> "XYePQR"
```

## 4.8
### 4.8.1
- each_with_indexメソッドを使うと、繰り返し処理で第2パラメータに添え字を渡すことができる。
```rb
fruits = ['apple','orange','melon']
# ブロックパラメータのiには0,1,2...と要素の添え字が入る
fruits.each_with_index {|fruit,i|puts"#{i}:#{fruit}"}
#=> 0:apple
# 1:orange
# 2:melon
```

### 4.8.2
- eachメソッド以外で、第2パラメータに添え字を渡したい場合は、繰り返しのメソッドとwith_indexメソッドを組み合わせて使う。
```rb
# mapメソッドを使う場合
fruits = ['apple','orange','melon']
# mapとして処理しつつ、添え字も受け取る
fruits.map.with_index{|fruit,i|"#{i}:#{fruit}"}
#=> ["0:apple","1:orange","2:melon"]

# delete_ifメソッドを使う場合
fruits = ['apple','orange','melon']
# 名前に"a"を含み、なおかつ添え字が奇数である要素を削除する
fruits.delete_if.with_index{|fruit,i|fruit.include?('a') &&i.odd?}
#=> ["apple", "melon"]
```
- with_indexメソッドは、Enumeratorクラスのインスタンスメソッドで、eachメソッドやmapメソッドなどの繰り返し処理を行うメソッドの大半は、ブロックを省略して呼び出すとEnumeratorオブジェクトを返すようになっている。

### 4.8.3
- with_indexメソッドで0以外の添字から処理を始めたい場合、引数を渡して処理をする。そうすると、渡した添字から処理が始まる。
```rb
fruits = ['apple','orange','melon']

#eachで繰り返しつつ、1から始まる添え字を取得する
fruits.each.with_index(1){|fruit,i|puts"#{i}:#{fruit}"}
#=> 1:apple
# 2:orange
# 3:melon

# mapで処理しつつ、10から始まる添え字を取得する
fruits.map.with_index(10){|fruit,i|"#{i}:#{fruit}"}
#=> ["10:apple","11:orange","12:melon"]
```
- each_with_indexメソッドでは引数使って添字の開始値を指定できないため、each.with_indexという形で実行する必要がある。

### 4.8.4
- 配列を含む配列の処理において、ブロックパラメータを複数設定すると、コードをシンプルに書くことができる。
- each_with_indexなど、元からブロックパラメータを複数扱うメソッドにおいては、配列を受け取るパラメータを括弧で囲むと良い。
```rb
dimensions = [
  [10,20],
  [30,40],
  [50,60],
]
# ブロックパラメータを()で囲んで、配列の要素を別々のパラメータとして受け取る
dimensions.each_with_indexdo|(length,width),i|
  puts"length:#{length},width:#{width},i:#{i}"
end
# => length:10,width:20,i:0
# length:30,width:40,i:1
# length:50,width:60,i:2
```

- 上記の手法は、入れ子になった配列を変数に多重代入する場合にも適用できる。
```rb
# ()を使わない場合はdimensionに配列の[10,20]が代入される
dimension,i=[[10,20],0]
dimension #=> [10,20]
i #=> 0

# ()を使うと内側の配列の要素（10と20）を別々の変数（lengthとwidth）に代入できる
(length,width),i=[[10,20],0]
length #=> 10
width #=> 20
i #=> 0
```

### 4.8.5
- Ruby２.7では、ブロックバラメータの代わりに番号してパラメータを指定できる。
```rb
# 番号指定パラメータを使わない場合（ブロックパラメータが1つ）
['1','20','300'].map{|s|s.rjust(3,'0')}
#=> ["001", "020", "300"]
# 番号指定パラメータを使う場合
['1','20','300'].map{_1.rjust(3,'0')}
#=> ["001", "020", "300"]
```
- ブロックパラメータに配列が渡される場合、番号指定パラメータの使い方によって値が変わってくるので要注意
<!-- 具体的な内容はいまいちわからなかったのでスキップ -->

- 従来のブロックパラメータと番号指定パラメータを一緒に使うと、エラーが発生する。
- タイプ量が減るので便利そうに見えるが、連番を使うとデータの中身がわかりづらくなるというデメリットがある。

### 4.8.6
- ブロックパラメータを;で区切り、続けて変数を宣言することで、ブロック内で有効なローカル変数を宣言することができる。

### 4.8.7
- ブロックは、配列やハッシュの繰り返し処理で利用されることが多いが、それ以外でも利用例がある。
- 以下はテキストファイルの文字列を書き込む例
```rb
#sample.txtを開いて文字列を書き込む（クローズ処理は自動的に行われる）
File.open('./sample.txt','w')do|file|
  file.puts('1行目のテキストです。')
  file.puts('2行目のテキストです。')
  file.puts('3行目のテキストです。')
end
```

### 4.8.8
- ブロックはdo..endと{}で囲む、どちらでも処理できるが、結合度に違いがある。{}の方が結合度が強い。
```rb
a = [1,2,3]
# ブロックを渡さないときは指定した値が見つからないとnilが返る
a.delete(100)
#=> nil

# ブロックを渡すとブロックの戻り値が指定した値が見つからないときの戻り値になる
a.delete(100) do
  'NG'
end
#=> "NG"

# ここで{}でブロックを渡すと、うまく動作しない。
# a.delete 100ではなく、a.delete 100 {'NG'}と解釈されてしまうため。
# 100はメソッドではないためブロックを渡すことができない。
a.delete100{'NG'}
#=> syntaxerror,unexpected'{',expectingendofinput(SyntaxError)

# 以下のように、メソッドの引数を確固で囲むと正常に動作する。
a.delete(100){'NG'}
#=>"NG"
```

### 4.8.9
- ブロック内のメソッドは自分で定義することができる。

### Column
- ブロックの後にメソッドを繋げて書くことができる。
```rb
names = ['田中','鈴木','佐藤']
names.map{|name|"#{name}さん"}.join('と')
#=>"田中さんと鈴木さんと佐藤さん"

# do..endでも同様にかける。少し読みづらいかも・・・
names=['田中','鈴木','佐藤']
names.map do |name|
  "#{name}さん"
end.join('と')
#=>"田中さんと鈴木さんと佐藤さん"
```

### Column
- 配列のメソッドは、公式のものでたいていのことができる。
- 公式メソッドを探す際は、ArrayクラスのメソッドとEnumerableメソッドどちらも確認すること。

## 4.9
### 4.9.1
- Ruby2.6以降では、終点を持たない範囲を指定できるようになった。
```rb
# 10以上を表す範囲オブジェクト（Ruby2.6以降）
(10..)
10..nil
```
- Ruby2.7以降では、始点を持たない範囲を指定できるようになった
```rb
# 10以下を表す範囲オブジェクト（Ruby2.7以降）
(..10)
nil..10
```
```rb
numbers=[10,20,30,40,50]
# 3番目以降の要素を取得
numbers[2..] #=> [30,40,50]
# 2番目以前の要素を取得
numbers[..1] #=> [10,20]
```
- 終端や始端がない範囲を指定することもできるが、利用することは滅多にない。

## 4.10
### 4.10.1
- timesメソッドは、繰り返し処理の回数を指定できる。

### 4.10.2
- nからmまで数値を増やす場合はupto、減らす場合はdowntoメソッドを使う。
```rb
a = []
10.upto(14){|n|a<<n}
a #=> [10,11,12,13,14]

a = []
14.downto(10){|n|a<<n}
a #=> [14,13,12,11,10]
```

### 4.10.3
- nからmまで、数値をxずつ増やしながら処理をする場合、stepメソッドを使う。
```rb
開始値.step(上限値, 一度に増減する大きさ)
```

### 4.10.4
- while文は、指定した条件が真で有る限り処理を続ける。
```rb
while 条件式(真であるかぎり有効)
  処理の内容
end

# 処理の後ろに修飾子として書くことで、1行にまとめて書ける
処理の内容 while 条件式
```
- どんな処理でも一度は実行したいという場合、while文をbeginとendで囲む
```rb
while false
  #このコードは常に条件が偽になるので実行されない
  a << 1
end
a #=> []

# begin...endで囲むとどんな条件でも最低1回は実行される
begin
a << 1
end while false
a #=> [1]
```

- whileの反対で、条件が偽の時に処理を実行するのがuntil文
```rb
until 条件式
  処理の内容
end
```

### 4.10.5
- 配列やハッシュに対し、for文で繰り返し処理を書くことができる。
- 以下の構文で記述する。
```rb
for 変数 in ハッシュや配列
  処理
end
```
```rb
numbers = [1, 2, 3, 4]
sum = 0
for n in numbers
  sum += n
end
sum#=>10
# doを入れて1行で書くことも可能
sum = 0
for n in numbers do sum += n end
sum #=>10
```
- eachと同様の繰り返し処理を書くことができるが、rubyではeach文を書くことが多い。
- 厳密には全く一緒ではなく、以下の違いがある。
  - 配列を受け取る変数や、for文の中で設定した変数が、for文の外でも使える。

### 4.10.6
- loopメソッドを使うことで、無限ループの処理を実行することができる。
  - 無限ループを終了するには、breakを用いる。
```rb
loop do
  # 無限ループの処理
end
```
### 4.10.7
- あるメソッドの中で、そのメソッドを再度呼び出すことを再起呼び出しという。
```rb
def factorial(n)
# 引数の値を1減らして、factorialメソッド自身をもう一度呼び出す（一種の繰り返し処理）
# 引数が0になったら1を返して繰り返し処理が終了する
  n > 0 ? n * factorial(n - 1) : 1
end
# 5 != 5 * 4 * 3 * 2 * 1を求める
```

### Column
- Arrayクラス、Rangeクラス、Enumeratorクラスは、Enumerableモジュールをincludeしている。そのため、Enmumarableモジュールに定義されているmapメソッドやselectメソッドを使うことができる。
- ArrayやRangeオブジェクトのメソッドを使う場合、Enumerableモジュールのメソッドも調べると良い。

## 4.11
- rubyには、繰り返し処理の制御を行う制御構造が用意されている。
  - break
  - next
  - redo
   
### 4.11.1
- 繰り返し処理の中でbreakを使うと、繰り返し処理を終了することができる。breakの後に条件式を記述する。
- breakに引数を渡すと、while文やfor文の戻り値になる。何も渡さないとnilが返される。
```rb
ret =
  while true
    break
  end
ret #=>nil

ret =
  while true
    break 123
  end
ret #=> 123 
```
- 繰り返し処理が入れ子になっている場合、一番内側の処理を脱出する。
```rb
fruits = ['apple','melon','orange']
numbers = [1,2,3]
fruits.each do |fruit|
  # 配列の数字をランダムに入れ替え、3が出たらbreakする
  numbers.shuffle.each do |n|
    puts"#{fruit},#{n}"
    # numbersのループは脱出するが、fruitsのループは継続する
    break if n == 3
  end
end
#=> apple,1
# apple,3
# melon,2
# melon,3
# orange,2
# orange,1
# orange,3
```

### 4.11.2
- 繰り返し処理の終了時、一番外側のループを脱出したい場合、catchとthrowを使う。
- タグには通常、シンボルを使う。
- catchとthrowのタグは一致させること。不一致の場合はエラーが出る。
```rb
catch タグ do
  # 繰り返し処理など
  throw タグ
end
```
```rb
fruits = ['apple','melon','orange']
numbers = [1,2,3]
catch :done do
  fruits.shuffle.each do|fruit|
    numbers.shuffle.each do|n|
      puts "#{fruit}, #{n}" if fruit == 'orange' && n == 3
      # すべての繰り返し処理を脱出する
      throw :done
      end
    end
  end
end
#=> melon, 2
# m¥elon, 1
# melon, 3
# orange, 1
# orange, 3
```

- throwタグに第二引数を渡すと、catchタグの戻り値となる。
```rb
ret = catch :done do
  throw:done, 123
end
ret #=>123
```

### 4.11.3
- breakとreturnは脱出するという似た機能を持っているが、内容は違っている。
  - breakは繰り返し処理から脱出する。
  - returnはメソッドから脱出する。
- 特段の事情がない限り、繰り返し処理の終了にreturnは使わない方が良い。

### 4.11.4
- 繰り返し処理を中断し、次の繰り返し処理に進めるにはnextを使う。(繰り返しのその回をスキップするイメージ？)
- 様々な繰り返し文の中で使える他、終了する場合は一番内側の繰り返し処理が終了する。
```rb
numbers = [1,2,3,4,5]
numbers.each do |n|
  # 偶数であれば中断して次の繰り返し処理に進む
  next if n.even?
  puts n
end
#=> 1
# 3
# 5
```

### 4.11.5
- 繰り返し処理をやり直したい場合はredoを使う。初回に戻るのではなく、その回の処理の最初に戻る。
```rb
foods = ['ピーマン','トマト','セロリ']
foods.each do |food|
  print "#{food}は好きですか？=>"
  answer = ['はい', 'いいえ'].sample
  put sanswer
  # はいと答えなければもう一度聞き直す
  redo unless answer == 'はい'
end
# =>ピーマンは好きですか？ => いいえ
# ピーマンは好きですか？ => いいえ
# ピーマンは好きですか？ => はい
# トマトは好きですか？ => はい
# セロリは好きですか？ => いいえ
# セロリは好きですか？ => はい
```
- redoを使うと、永遠に続くループが発生してしまうことがある。その場合は回数を指定する。
```rb
foods=['ピーマン','トマト','セロリ']
count = 0
foods.each do |food|
  print"#{food}は好きですか？=>"
  # わざと「いいえ」しか答えないようにする
  answer = 'いいえ'
  puts answer
  count += 1
  # やりなおしは2回までにする
  redo if answer!='はい' && count < 2
  # カウントをリセット
  count = 0
end
#=> ピーマンは好きですか？ => いいえ
# ピーマンは好きですか？ => いいえ
# トマトは好きですか？ => いいえ
# トマトは好きですか？ => いいえ
# セロリは好きですか？ => いいえ
# セロリは好きですか？ => いいえ
```
### Column
- エイリアスメソッドが存在する理由
  - 他の言語の影響を受けているから
  - 直感的に思い浮かんだ名前でメソッドを実行したいから
  - 後からもっと良いメソッド名が提案されたから
  - 短く書きたいから、英語として自然に書きたいから
