# 2 Rubyの基礎を理解する
## 2.2 Rubyに関する基礎知識
### 2.2.1
- Rubyはオブジェクト指向言語
- 文字列や配列、数値、nilまで全てがオブジェクトである。
### 2.2.2
- `オブジェクト.メソッド(引数1, 引数2, 引数3)`とすることで、オブジェクトに対してメソッドを実行できる。
- `オブジェクト.メソッド 引数1, 引数2, 引数3`のように括弧を省略できる。
    
### 2.2.3 文の区切り
- 基本的には改行が文の区切りとなる。
- `;`を使って文の区切りを示すことはできるが、使用頻度は高くない。１行に複数行分を記述する場合に使う。
- 文が続くことが明らかな場合は、文の途中で改行することができる
```rb
 User.create(
  name = 'Andy'
 )
```
- バックスラッシュを使うと、文がまだ続くことを示す。使用頻度は高くない。
```rb
 User.create(name \
 = 'Andy')
```
### 2.2.4 コメント
- Rubyでは、`#`を付けてコメントを示す。複数行のコメントも`#`を使うことが多い。
- `=begin`と`=end`を使うと、複数行のコメントを書くことができる。（滅多に使わない）
  - これは、コード内にRDocと呼ばれるドキュメントを埋め込むためのもの。
  - 通常の複数行のコメントには、毎行の行頭に`#`をつける。
```rb
=begin
これはコメント
これもコメント
=end
```
- 複数行のコメント指定のショートカットを覚えること。

### 2.2.5 識別子と予約語
- 変数やクラス、メソッドにつける名前を識別子と呼ぶ。
- Rubyの識別子には英数字のほか、非ASCII文字（漢字や平仮名）を使うこともできるが、英数字を用いるのが一般的。
- アンダースコアも識別子に使うことができる。
- 通常、予約後は識別子として使用することはできない。

### 2.2.6 空白文字
- 識別子と予約語を区切るために設置される。
- いくつ空いても処理には影響しないことが多いが、たくさん空けると見辛い。
- メソッド呼び出しの後のカッコは、空白文字をおかないこと。

### 2.2.7 リテラル
- リテラルとは、ソースコードに直接埋め込むことができる値のこと
  - 数値（整数）
  - 文字列
  - 配列
  - ハッシュ
  - 正規表現

### 2.2.8 変数（ローカル変数）の宣言と代入
- Rubyでは、変数の宣言と代入を同時に行う。宣言だけはできない。
- 慣習的に、変数は小文字のスネークケースで書く。
- 変数は小文字の英字、またはアンダースコアから始まり、小文字の英字と数字、アンダースコアで構成する。
  - 数字から始まる変数を設定すると、エラーになる。
- 一般的ではないが、非ASCII文字を変数にすることもできる。

## 2.3
### 2.3.1
- Rubyで文字列を作る方法として、シングルクオーツやダブルクオーツで囲むという方法がある。
- 違いとして、ダブルクオーツで囲んだ文字列では、改行文字等や式展開を使うことができるというものがある。
  - シングルクオーツの中で改行文字や式展開を書いても、ただの文字列として認識されるため、シングルクオーツの中でこれらは使えない。
- ダブルクオーツを使った式の中で、改行文字や式展開を打ち消したい場合は、式展開や特殊文字の前にバックスラッシュを置いてエスケープする。

### 2.3.2
- 左右の文字列がが同じ値かを調べる場合は`==`を使う。
- 左右の文字列がが違う値かを調べる場合は`!=`を使う。
- 左右の文字列等の大小を比較する場合は`<`などを使う。
  - これについて、文字列はバイト数の大小を比較する。

## 2.4
- 数字の表記において、アンダースコアは無視される。
  - 任意の区切り文字に使用すると良い。
- 四則演算の記号を使って計算もできる。
- 変数に数値を代入した場合に、変数の前にマイナスをつけると、代入された値の取得に影響する。
```rb
n = 1
-n #=> -1
```
- 整数どうしの割り算は整数を返す。小数点以下は切り捨てられる。
- 小数点以下を取得する場合、割り算の割る方/割られる方どちらかに小数点以下を記述する。
```rb
3.0 / 2 #=> 1.5
```
- 変数に小数点以下が格納されている場合、`to_f`メソッドを使うことで、整数から小数点以下を含む数値に変換できる。
- `%`は割り算の剰余を求めることができ、`*＊`はべき乗を求めることができる

### 2.4.1
### 2.4.2
- 数学と同様に乗算と割算は、足算と引算より優先順が高い（先に計算される）
- 括弧を用いることで、計算の順序を変えることができる。
- 演算子の優先順位は以下の通り
```rb
# 高い
  ::
  []
  +（単項） ! ~
  **
  -（単項）
  * / %
  + -
  << >>
  &
  | ^
  > >= < <=
  <=> == === != =~ !~
  &&
  ||
  .. ...
  ?:（条件演算子）
  =（+=、=…）
  not
  and or
# 低い
```

### 2.4.3
- 変数の増減についての演算子はRubyに用意されていない。
- その代わり、以下のような構文を使うことができる。
  - 足算以外の演算でも同様に動作する。
```rb
n = 1
n = n + 1
#=> 2

n = 1
n += 1
#=> 2
```
### Column
- Rubyに置いて、数値っぽい値を暗黙的に数値に変換することはないため、to_iメソッドを使って、明示的に数値に変える必要がある。
- 反対に、数値を文字列のように扱うこともできないため、to_sメソッドを使い、明示的に文字列に変える必要がある。

### Column
- 小数を使う場合、丸め誤差がに注意する必要がある。
  - コンピュータは2進数で計算しているため、誤差が生じる。
- これを解消するには、少数の後にrをつけることで、数値がRational（有理数）クラスの数値とする。
- 変数に少数が入っている場合、rationalizeメソッドを使うことでRationalクラスの計算とすることができる。
- 普通の少数に戻す場合、to_fメソッドを使う。

## 2.5
### 2.5.1
- Rubyにおいては、falseやnilであれば偽、それ以外は正となっている。
- ポイントとして、nilがfalseとなる点。（他の言語では違ったりする）

### 2.5.2
- `条件1 && 条件2`は「条件1かつ条件2」という条件を表す
- `条件1 || 条件2`は「条件1または条件2」という条件を表す
- `条件1 && 条件2 || 条件3 && 条件4`といったように組み合わせて使用することもできるが、&&の方が優先順が高いため、括弧を使うと(条件1 && 条件2)||(条件3 && 条件4)と解釈される。
  - この優先順を変えたい場合、括弧を使う。

### 2.5.3

## 2.6
### 2.6.1
- メソッドの戻り値は、定義する際には記述しない
  - Rubyでは、最後に評価された式の結果が戻り値となる。
  - 他の言語で使われるreturnは、メソッドの途中で処理を終了する場合に使われる。
### 2.6.2
- メソッドに引数を渡すときは、慣習的に括弧をつける。（付けなくても正しく動作する）
- メソッドに引数を渡さないときは、慣習的に括弧を付けない（付けても良いが読みづらい）

## 2.7
### Column
- irbを使う際に書き込む量が多いと、間違いが発生した場合の対応が大変になってしまう。一度テキストエディタで下書きし、irbに貼り付けるのが良い。

## 2.8
### 2.8.1
- 全ての文字列は、Stringクラスのオブジェクト

### 2.8.2
- 文字列を作る手法として、％記法がある。
- %記法では、シングルクオートやダブルクオートをエスケープする必要がないというメリットがある。
```rb
# %q!!はシングルクオートで囲んだことと同じになる
puts %q!Hesaid,"Don'tspeak."! #=> He said,"Don'tspeak."
# %Q!!はダブルクオートで囲んだことと同じになる（改行文字や式展開が使える）
something = "Hello."
puts %Q!He said,"#{something}"! #=> He said,"Hello."
# %!!もダブルクオートで囲んだことと同じになる
something = "Bye."
puts %!He said,"#{something}"! #=> Hesaid,"Bye."
```
- 上記を％記法を使わないで記述した場合は以下のようになる。シングルクオートやダブルクオートをバックスラッシュでエスケープする必要がある。
```rb
puts 'He said, "Don\'tspeak."' #=> He said, "Don't speak."

something = "Hello."
puts "He said, \"#{something}\"" #=> He said,"Hello."

something = "Bye."
puts "He said, \"#{something}\"" #=> He said,"Bye."
```
- 上記で区切り文字に`!`を使ったが、他の任意の文字でも問題なく動作する。各種括弧を使う場合、閉じ括弧は最初の括弧に対応するものにする必要がある。
### 2.8.3
- 文字列は、途中で改行することができる。
```rb
puts "Line1,
Line2"
#=> Line1,
```
- 複数行にまたがる長い文字列を作成する場合、ヒアドキュメント（行指向文字列リテラル）を使うのが良い。
```rb
a = <<TEXT
1行目
2行目
3行目
TEXT

puts a
#=> 1行目
2行目
3行目
```
- 識別子は任意の文字を使用することができる。慣習的に大文字を使うのが良い。
- `<<-`を使うと、最後の識別子をインデントすることができる。
- `<<~`を使うと、内部の文字列をインデントしても、先頭の空白が無視される。
  - `<<~`を使いつつ、インデントの先頭の空白を有効にしたい場合、空白の前にバックスラッシュをつける。
```rb
def some_method
  <<~TEXT
    \  各行の行頭に半角スペースを2文字入れます。
    \  このとき行頭はバックスラッシュで指定します。
  TEXT
end
puts some_method
#=>  各行の行頭に半角スペースを2文字入れます。
#  このとき行頭はバックスラッシュで指定します。
```
- ヒアドキュメント内では、式展開が有効となる。
- 式展開を使う場合において、識別子をシングルクオートで囲むと、式展開が無効になる。
```rb
name = 'Alice'
a = <<'TEXT'
ようこそ、#{name}さん！
以下のメッセージをご覧ください。
TEXT
puts a
#=> ようこそ、#{name}さん！
# 以下のメッセージをご覧ください。
```
- 一方、`<<"TEXT"`といったように識別子をダブルクオートで囲むと、式展開が有効になる。
- 識別子をダブルクオートで囲む場合、改行文字も有効に認識される。（識別子をシングルクオートで囲むと認識されない）
- 開始ラベルの`<<識別子`は一種の式とみなされるため、メソッドの引数として渡したり、識別子に対してメソッドを呼び出すことができる。

### 2.8.4
- sprintfメソッドを使うと、指定されたフォーマットの文字列を作成することができる。

### 2.8.5

### 2.8.6
- Rubyにおいて、文字と文字列（1文字か複数文字か）は区別せず、全てStringクラスのインスタンスとなる）
- 頭に`?`をつけると、文字列となる。
```rb
?a #=> "a"
```

## 2.9
### 2.9.1
- 基数指示子を頭につけると、10進数以外の記数法で整数値を書くことができる。
  - 2進数は`0b`、8進数は`0`または`0o`、16進数は`0x`
```rb
# 2進数
0b11111111 #=> 255
# 8進数
0377 #=> 255
0o377 #=> 255
# 16進数
0xff #=> 255
```
- `0d`をつけると10進数を表すことができる。

### 2.9.2
- 整数値は、演算子を使うことでビット演算ができる。ビット演算とは、整数値の2進表現に対応したビット列に関する演算
  - & ビットごとの論理積（AND）
  - | ビットごとの論理和（OR）
  - ^ ビットごとの排他的論理和（XOR）
  - >> 右ビットシフト
  - << 左ビットシフト
  - ~ ビットごとの論理反転（NOT）

### 2.9.3
- 指数表現を使って浮動小数点を表すことができる。
```rb
2e-3 #=> 0.002
```

### 2.9.4
- Rubyでは、数値のクラスがいくつかあるが、おおもとにNumericクラスがあり、各種クラスはこれを継承している。
[![Image from Gyazo](https://i.gyazo.com/a7df73ed4f1be5edd4b481860183b79a.png)](https://gyazo.com/a7df73ed4f1be5edd4b481860183b79a)

## 2.10
### 2.10.1
- &&や||を使った場合、trueやfalse以外の値が返ることがある。
- Rubyでは式を左から右に評価し、式全体の真偽が確定すると式の評価を終了し、最後に評価した式の値を返す。
- 式全体の真偽値が確定した時点で評価を終了する評価法を短絡評価（ショートサーキットという）

### 2.10.2
- && || !に近い働きをする演算子として、and or notがある。
- 意味は同様だが、優先順が違うため、全く同じようには使えない。
- and orは優先順に違いがないため、左から順に真偽値を評価する。
- andやorなどは、条件分岐でなく制御フローに向いている。
  - もちろん、&&でも書けるので、その辺は好みで良さそう。
```rb
# andを使う場合
user.valid? and send_mail_to user
# &&を使う場合
user.valid? && send_mail_to(user)
```

### 2.10.3
- unlessは条件式が偽のときに処理が実行される条件分岐
- elseの中で、条件が偽（つまり、真）の場合の処理を書くことができる。
  - unlessの中でelsifは使うことができない。
- ifと同様に、戻り値を変数に代入したり、修飾子として文の後ろに置いたり（後置unless）することができる。
- ifの条件分岐の中で否定を使う場合はunlessを使うことができるが、必ず書き換える必要があるものではなく、読みやすい方をOK

### Column
- == trueや==falseといった書き方はしないこと。

### 2.10.4
- 条件を複数の値と比較する場合、case文を使うと良い。
- caseも最後に評価された式を戻り値として返すため、case文の結果を変数に代入することができる。
- whenに渡す値として、範囲、正規表現、クラスなどのオブジェクトを使うことができる。

### 2.10.5
- シンプルなif文は三項演算子（条件演算子）を使う方がスッキリする場合もある。

## 2.11
- rubyでは、メソッドの引数の過不足があると構文エラーとなる。
- この引数過不足のエラーを回避する方法として、引数のデフォルト値を設定するというものがある。
```rb
#引数なしの場合はcountryに'japan'を設定する
def greet(country='japan')
  if country == 'japan'
    'こんにちは'
  else
    'hello'
  end
end
greet #=>"こんにちは"
greet('us') #=>"hello"
```
- デフォルト値の有無を混ぜることもできる。
```rb
def default_args(a,b,c=0,d=0)
  "a=#{a},b=#{b},c=#{c},d=#{d}"
end
default_args(1,2) #=>"a=1,b=2,c=0,d=0"
default_args(1,2,3) #=>"a=1,b=2,c=3,d=0"
default_args(1,2,3,4) #=>"a=1,b=2,c=3,d=4"
```
- デフォルト値には、動的な値や他のメソッドの戻り値を指定することもできる。
- デフォルト値には、左にある引数を使うこともできる。
```rb
#yが指定されなければxの値をyに設定する
def point(x, y=x)
  puts "x=#{x}, y=#{y}"
end
point(3)  #=>x=3,y=3
point(3,10) #=>x=3,y=10
```

### 2.11.2
- rubyのメソッドは?や!で終わらせることができる。
- ?で終わるメソッドは、慣習として真偽値を返す。これを述語メソッドという。
```rb
# 空文字列であればtrue、そうでなければfalse
''.empty? #=>true
'abc'.empty?  #=>false

# 引数の文字列が含まれていればtrue、そうでなければfalse
'watch'.include?('at')  #=>true
'watch'.include?('in')#=>false
# 奇数ならtrue、偶数ならfalse
1.odd?  #=>true
2.odd?  #=>false

#偶数ならtrue、奇数ならfalse
1.even? #=>false
2.even? #=>true

#オブジェクトがnilであればtrue、そうでなければfalse
nil.nil?  #=>true
'abc'.nil?  #=>false
1.nil?  #=>false
```
- このようなメソッドは自分で定義することもできる。真偽値を返すメソッドは、？で終わらせ他方が良い。

### 2.11.3
- 呼び出した値そのものを変えてしまうメソッドのことを破壊的メソッドという。
- 破壊的メソッドは自分で作成することもできる。

### Column
- 末尾に!がつくメソッドすべてが破壊的メソッドというわけではない。
- 以下のルールで命名されている。
  - !がつくメソッドは、つかないメソッドより危険という意味を持つ。
  - 非破壊的メソッドと破壊的メソッドの２種類が存在する場合、破壊的メソッドに!がつく。
  - 破壊的メソッドであっても、非破壊的メソッドが存在しない場合は!がつかない。
  - 破壊的かどうかに関係なく、安全なメソッドと危険なメソッドが存在する場合、危険なメソッドには!がつく。

### 2.11.4
- Ruby3.0では、エンドレスメソッドが導入された。
```rb
# 通常のメソッド定義
def greet
  'Hello!'
end

# エンドレスメソッド定義（=に続けて処理や戻り値を書く）
def greet = 'Hello!'

# ただし、メソッド名と=の間にスペースがないと構文エラーとなる。

#通常のメソッド定義（引数を持つ場合）
def add(a,b)
  a + b
end

#エンドレスメソッド定義
def add(a, b) = a + b

add(1, 2) #=>3

#ただし、引数の()を省略すると構文エラーが発生するので要注意
```
- Ruby3.0において、エンドレスメソッド定義構文は実験的な扱いのため、要注意。

## 2.12
### 2.12.1
- Rubyには画ベージコレクションという機能がある。
- これは、使用されなくなったオブジェクトを回収し、自動的にメモリを解放する。これにより、プログラマはメモリ管理を意識する必要がなくなる。

### 2.12.2
- 全く同じ実装で名前だけ異なるメソッドをエイリアスメソッドという。
- 同じメソッドに複数の名前が用意されている場合、開発者の好みで選んでOK

### 2.12.3
- 式と文について、以下のように定義することができる。 
  - 値を返し、結果を変数に代入できるものが式
  - 値を返さず、変数に代入できない（しようとすると構文エラーが発生する）ものを文
- rubyにおいては、厳密に区分されているものではなく、if文など、値を返すものも文として扱うことがある。

### 2.12.4
- nilやtrue、falseは疑似変数と呼ばれる特殊な変数。
- Rubyには、他にも下記のような疑似変数がある。
  - self オブジェクト自身
  - _FILE_ 現在のソースファイル名
  - _LINE_ 現在のソースファイル内の行番号
  - _ERNCODING_ 現在のソースファイルのスクリプトエンコーディング
- 擬似変数は、値の取得はできるが、代入はできない（エラーが発生する）

### 2.12.5
- Rubyの変数には、オブジェクトそのものでなく、オブジェクトへの参照が格納されている。
- 変数がどのオブジェクトを参照しているかは、object_idで確認できる。
- 参照されているオブジェクトの値が変更となった場合、それを参照する変数の値も書き変わる。

### 2.12.6
- Rubyでは、多くのライブラリが標準ライブラリとして用意されている。
- 標準ライブラリの中でも、特に利用頻度が高いライブラリは組み込みライブラリとして提供されている。
  - StringクラスやIntegerクラスは標準ライブラリであり、組み込みライブラリでもある。
  - Dateクラスなどは、標準ライブラリであるが、組み込みライブラリではない。
- 有志が開発している外部ライブラリはgemと呼ばれる形式で用意されている。
- 標準ライブラリは、インストール不要だが、gemは別途インストールが必要。

### Column
- 標準ライブラリはgem化が進んでいる。
- 標準ライブラリで用意されているため、別途gemを用意しなくても使えるが、単体のgemでもバージョンアップが実施されているため、gemだと先に最新版を利用できるというメリットがある。

### 2.12.7
- 組み込みライブラリでない標準ライブラリを利用する場合、明示的にそのライブラリを読み込ませる必要がある。
```rb
  require 'ライブラリ名'
```
- 自分で作成したRubyプログラムを読み込む場合、require_relativeを使う。
  - これは、自ファイルからの相対パスで読み込むファイルを指定するもの。
  - requireで絶対パスを使うことで読み込むこともできるが、推奨されない。カレントディレクトリの場所によって、実際に読み込まれるファイルが異なるケースが発生しうるため。

### 2.12.8
- puts print p ppメソッドは、似ているが挙動は微妙に違っている。

- putsは、改行を加えて変数の内容やメソッドの戻り値をターミナルに出力する。puts自身の戻り値はnilである。
- printメソッドは、改行を加えない。
- pはputsと同様に改行を加えて出力する。文字列を出力すると、文字列はダブルクオートで囲まれる。pメソッドでは、渡した引数そのものが戻り値となる。
- ppメソッドは、複雑な配列やgハッシュ、オブジェクトの内容を見やすく整形して出力する。pメソッドど同様に、引数として渡したオブジェクトがそのまま戻り値となる。

- putsやprintでは、改行文字を認識して出力する（改行文字があると改行される）pやppでは、改行文字を認識しない（改行文字がただの文字列として扱われる。）
- 配列の出力について、putsやプリントは、出力した配列の要素ごとに改行して出力される。pでは、配列がそのまま出力される（要素ごとに改行しない）
- 内部的には、putsやprintではto_sメソッドを使ってオブジェクトを文字列にしている。pはinpsectメソッドを使ってオブジェクトを文字列にしている。どちらのメソッドも、オブジェクトを文字列に変換するという動作は変わらないが、inspectメソッドは開発者向けの情報を返すため、pは開発者向けと見なすことができる。


[![Image from Gyazo](https://i.gyazo.com/0614f11036a1327d77e00c657b1300c2.png)](https://gyazo.com/0614f11036a1327d77e00c657b1300c2)

### Column
- putsやpはグローバル関数ではないが、グローバル関数用のように使えるメソッド

### Column
- 括弧をつけるかどうかについては、以下は慣習的に括弧を省略する。
    - 引数がない場合。
    - putsのように、グローバル関数っぽく使えるメソッドを使う場合
    - requireやraiseなど、Rubyの予約後っぽく見える言語
- 逆にいうと、以下は慣習的に括弧をつける。
  - オブジェクトに対するメソッドの呼び出しで、引数がある。
  - 独自に定義したメソッドで、引数がある。
- 括弧を必ずつける場合（つけないと構文エラー）
```rb
# 引数と{}のブロックを付けてメソッド呼び出しする場合は()を省略できない（省略すると構文エラー）
[1,2,3].delete(100){'NG'}

# 第1引数にハッシュの{}が来る場合は()を省略できない（省略すると構文エラー）
puts({a:1})
```