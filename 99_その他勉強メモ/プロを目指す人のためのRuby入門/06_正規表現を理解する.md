## 6.1
- 正規表現とは、パターンを指定して文字列検索や置換を行う一種のミニ言語

## 6.2 正規表現って何？
- 筆者の言葉では「正規表現とは、パターンを指定して文字列検索や置換を行う一種のミニ言語」
- Rubyだけの機能ではなく、様々なプログラミング言語で使用されている。言語によって実行環境は異なるものの、考え方は共通している。
- 英語では、RegularExpressionRegularExpressionといい、RubyのRegexpクラスはこの単語に由来している。

## 6.2.1 正規表現の便利さを知る


# 6.3
- 正規表現は`/`で囲んで表現する。
- Rubyにおいて正規表現は、Regexpクラスのオブジェクトとなる。
- `=~`を使うと、最初にマッチした位置（０以上の数値）が帰り、マッチしなかった場合はnil`を返す。
  - マッチした場合は真、しなかった場合は偽となるため、if文などの条件分岐にも使われる。
  - また、Rubyにはマッチしたかどうかを確認する`match`や`match?`メソッドが用意されている。

### 6.3.3
- キャプチャの中にて、`(?<hogehoge>)`と書くと、hogehogeに続くものに名前をつけることができる。
- キャプチャに名前をつけることで、順番を気にしなくてよくなる。
- 左辺に正規表現リテラルを、右辺に文字列を置き、`=~`を使うと、キャプチャの名前をそのままローカル変数として使える。
### 6.3.4 
### 6.3.5
#### scan
- 引数に正規表現を渡すと、マッチした正規表現の配列を返す。
- 引数にキャプチャがあると、キャプチャされた部分が配列となる。

#### [] slice slice!
- `[]`に正規表現を渡すと、マッチした部分を抜き出してくれる。
- マッチした部分が複数ある場合、最初にマッチした箇所を返す
- キャプチャを使い、第２引数で数字を渡すと、n番目のキャプチャを返す。
- 名前付きキャプチャを使うと、第2引数でハッシュを渡すことで、任意のキャプチャを指定できる。
- `slice`メソッドは`[]`のエイリアスのため、同様に動作する。
- `slice!`を使うと、マッチした部分が破壊的に取り除かれる。

#### split
- `split`に正規表現を渡すと、マッチした文字列で区切り、配列にして返す
- 第2引数で、正規表現を使って区切り文字を複数指定することもできる（orで指定する）

#### gsub gsub!
- `gsub`を使うと、第1引数にマッチした文字列を、第2引数の文字列に置換する。
- 第2引数にハッシュを渡し、変換のルールを複数指定することもできる。
```
text = `123, 456-789`
hash = { ','=>';', '-'=>':'}
text.gsub(/,|-/, :hash)
#=> '234;456:789'
```
- 第2引数を渡す代わりに、ブロックを渡すことで置き換える文字列を指定できる。
```
text = `123, 456-789`
text.gsub(/,|-/) { |matched| matched == ',' ? ':' : '/' }
#=> '234;456:78
```
- `gsub`や`gsub!`はキャプチャを組み合わせて文字列を変換できる。
  - キャプチャを使う場合、第2引数に文字列を渡す方法、ブロックを渡す方法の２種類のやり方がある。
  - 第2引数に文字列を渡す場合、`\1`や`\2`を使って、キャプチャした文字列を連番で参照できる。この際にダブルクォートを使うと、バックスラッシュをエスケープする必要があるため、要注意。この手段では、第2引数の文字列が複雑になってしまうため、ブロックを渡す手法を利用することができる。
  - 下記のように、変換後の内容をブロックで渡すと、ダブルクォートを使った時のバックスラッシュのエスケープを気にしなくて良くなる。
```
text.gsub(/(\d+)年(\d+)月(\d+)日/) do
  "#{$1}-#{$2}-#{$3}"
end
```
- 名前付キャプチャを使う際も、同様にブロックを使うことでバックスペースのエスケープを回避できる。
- 公式リファレンスでは、ブロックを渡す手法が推奨されている。

## 6.4
自分でテストを作ってみる課題

## 6.5
### 6.5.1
- 正規表現のオブジェクトを示すには、スラッシュで囲む以外にもいくつか手法がある。
  - Regexp.newの引数にパターンの文字列を渡す方法
  - `%r`を使う記法（パーセント記法）
```
# スラッシュで囲む場合、バックスラッシュでエスケープする必要がある。
/https:\/\/example\.com/
# %rをを使うと、メタ文字をエスケープしなくて良い。
%r!https://example.com!
# パーセント記法を使う際、`!`ではなく`{}`で囲むことも可能。個人的にはこっちのほうが好みかも
%r{https://example.com}

```
### 6.5.2
- case文のwhen節で正規表現を使うことができる。

### 6.5.3
- 正規表現オブジェクトを作成する際は、オプションを指定することができる。
- `/正規表現/オプション`と記述する。
##### iオプション
- iオプションを使うと、大文字と小文字を区別しない。
- スラッシュで囲む記法だけでなく、%記法でも使用可能。
```
'HELLO' =~ /hello/i #=> 0
'HELLO' =~ %r{hello}i #=> 0
# Regexp.newを使う場合、Regexp::IGNORECASEという定数を渡す。
regexp = Regex.new('hello', Regex::IGNORECASE)
'HELLO' =~ regexp #=> 0
```

##### mオプション
- 任意の文字を表す.(ドット)が改行文字にマッチするようになる
```
# mオプションをつけない場合
'Hello\nBye' =~ /Hello.Bye/ #=> nil
# mオプションをつけた場合、改行文字にもマッチするようになる。
'Hello\nBye' =~ /Hello.Bye/m #=> 0
# Regexp.newを使う場合、Regexp::MULTILINEという定数を渡す。
regexp = Regex.new('Hello.Bye', Regex::MULTILINE)
'Hello.Bye' =~ regexp #=> 0
```
##### xオプション
- xオプションを使うと、空白文字が無視されるため、正規表現の中に#を使ってコメントを書くことができる。
```
# xオプションを付けたので改行やスペースが無視され、コメントも書ける
regexp = /
  \d{3} # 郵便番号の先頭3桁
  - #区切り文字のハイフン
  \d{4} #郵便番号の末尾4桁
  /x
  '1234567' =~ regexp #=>0
```
- xオプションを使う際、空白を無視しない場合は、空白の前にバックスラッシュをつけてエスケープする。
- Regexp.newを使う場合、Regexp::MULTILINEという定数を渡す。
```
regexp = Regex.new('Hello.Bye', Regex::MULTILINE)
'Hello.Bye' =~ regexp #=> 0
```
- Regexp.newでxオプションを使う場合
```
#バックスラッシュを特別扱いしないように'TEXT'を使う
pattern=<<'TEXT'
  \d{3} #郵便番号の先頭3桁
  - #区切り文字のハイフン
  - \d{4} #郵便番号の末尾4桁
TEXT
regexp = Regexp.new(pattern,Regexp::EXTENDED)
```
##### その他補足
- オプションを複数使う場合は連続して書く
```
#iオプションとmオプションを同時に使う
"HELLO\nBYE" =~ /Hello.Bye/im #=>0
```
- Regexp.newでオプションを複数使う場合、`|`を使って連結する。
```
regexp = Regexp.new('Hello.Bye',Regexp::IGNORECASE | Regexp::MULTILINE)
"HELLO\nBYE" =~ regexp #=>0
```
### 6.5.4
- Match Dataクラスとは、マッチした結果が格納される。
- Regexp.last_matchメソッドを使うと、最後にマッチした結果をMatchDataMatchDataオブジェクトとして取得できる。
  - $~などの組み込み変数より可読性は上がるものの、暗黙的に値が設定される点があるため、多用は避けた方が良い。
### 6.5.5
- match?メソッドは、正規表現にマッチすればtrue、しなければfalseを返す。
  - matchメソッドと異なる点は、組み込み変数やRegexp.last_matchの内容を書き換えないため、高速で動作するという点。

## コラム
- 正規表現は多くのプログラミング言語で使えるが、使えるメタ文字やメタ文字の意味は言語ごとに微妙に異なる。
- Webサービスを使って正規表現を使用する場合、その言語に最適化されているか確認すること。