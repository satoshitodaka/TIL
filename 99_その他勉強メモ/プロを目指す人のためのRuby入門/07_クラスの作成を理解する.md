# 7.2 
## 7.2.1　クラスを使う場合と使わない場合の比較
#### クラスを使わないプログラム
- プログラムの中でハッシュを使う場合、タイプミスで正しい値を取得できないと、nilを返してしまう。
  - nilを返す場合は間違いに気づきづらいため、メンテナンス上のリスクが残る。
- ハッシュを使って新しいキーを追加したり、内容を容易に変更できるので、「脆くて壊れやすプログラム」になりやすい。

#### クラスを使うプログラムについて
- クラスというデータの型を導入し、そこにデータを入れていくと、堅牢なプログラムになる。
- タイプミスに対してエラーを吐いてくれるし、新しい属性の追加や変更も防止できる。

#### クラスの内部にメソッドを追加する。
- クラスの内部にメソッドを追加できる。
- 内部にメソッドを追加すると、渡す引数が少なくなり、シンプルに実装できる。

## オブジェクト指向プログラミング関連の用語
#### クラス
- 一種のデータ型のこと。オブジェクトの設計図、オブジェクトの雛形と呼ばれることがある。
- Rubyであれば、オブジェクトは何らかの￥クラスに属している。
- クラスが同じであれば、保持している属性や使えるメソッドは同じとなる（例外あり？）

#### オブジェクト、インスタンス、レシーバ
- オブジェクトは、クラス（設計図）から作成するもので、個別の情報を保持している一連のデータのかたまり。
- 例として、果物クラスから生成した、りんごオブジェクト、みかんオブジェクト、など。
- 場合によってはインスタンスと呼ぶこともある。
- メソッドとの関係の説明において、オブジェクトはレシーバと呼ばれる。

#### メソッド、メッセージ
- メソッドは、オブジェクトが持つ動作や振る舞いのこと。
- 何らかの処理を一纏めにして名前をつけ、何度も呼び出せるようにしたもの。
- 場合によっては、メソッドはメッセージと呼ばれることもある。（SmallTalkの影響）

#### 状態（ステート）
- オブジェクトごとに保存されるデータのことを、「オブジェクトの状態（ステート）」と呼ぶことがある。

#### 属性
- オブジェクトから取得できる値のことを属性と呼ぶ。
- 多くの場合、属性の名前は名詞になっている。
# 7.3 クラスの定義
- クラスの定義は以下の構文で行う。
  - 必ず大文字で始めること。
  - キャメルケースで書くのが一般的
```
class クラス名
end
```

## 7.3.1 オブジェクトの作成とinitializeメソッド
- クラスからオブジェクトを作成する場合、`new`メソッドを使う。
- この時に呼ばれるのが`initialize`メソッド。
- インスタンスを初期化をしたい場合もこのinitializeメソッドを定義する（不要であれば省略する）
- initializeメソッドは特殊なメソッドで、デフォルトでprivateメソッドとなっているため、外部から呼び出すことができない。
- initializeメソッドに引数を設定すると、ｎｅｗメソッドを呼ぶ時に引数が必要となる。

## ７.3.2 インスタンスメソッドの定義
- ***クラス構文の中にメソッドを定義すると、これはインスタンスメソッドとなる。***
  - インスタンスは、文字通りインスタンス（オブジェクト）に対して実行するメソッド

## 7.3.3 インタンス変数とアクセサメソッド
- クラス内部ではインスタンス変数を使うことができる。
  - インスタンス変数とは、同じインスタンス（オブジェクト）の内部で共有することができる変数
  - Rubyでは＠から始まる変数。
- プレフィックス（接頭辞）がつかない変数はローカル変数
- ローカス変数やメソッドのスコープ（有効範囲）は、それ自身が宣言された位置から、宣言されたメソッドやブロックの終わりまで、
- ローカル変数は、参照する前に必ず値を代入して作成する必要がある。未作成のローカル変数を参照するとエラーが発生する。
- インスタンス変数は、作成する前に参照してもエラーにならない。未作成の変数を参照すると、nilを返す。
  - インタンス変数についてタイプミスがあると、思いがけない不具合が発生するので要注意。
- インスタンス変数はクラスの外部から参照することはできない。
  - インスタンス参照する場合、参照用のメソッドを作成する必要がある。
- 同様に、インスタンス変数はクラスの外部から直接編集することができない。
  - インスタンスメソッドを変更する場合、変更用のメソッドを用意する。
```
class User
  def initialize(name)
    @name=name
  end
  
  #@nameを外部から参照するためのメソッド
  def name
    @name
  end
  
  #@nameを外部から変更するためのメソッド
  def name=(value)
    @name=value
  end
end
user=User.new('Alice')
#変数に代入しているように見えるが、実際はname=メソッドを呼び出している
user.name='Bob'
user.name#=>"Bob"
```
- 値を読み出すメソッドをゲッターメソッド、値を書き込むメソッドをセッターメソッドという。（値をGETするメソッド、SETするメソッド）
- これらを総称してアクセサメソッドという。
- Rubyにおいては、attr_accessorメソッドを定義することで、メソッドの定義を省略することができる。
```
class User
  attr_accessor :name
  
  def initialize(name)
    @name = name
  end
  
# セッターメソッドを定義しなくてもOK
end

user = User.new('Alice')
user.name = 'Bob'
user.name #=> 'Bob'
```
- インスタンス変数の内容を読み取り専用にしたい場合、attr_readerメソッドを使う。
- 逆に、インスタンス変数の内容を書き込み専用にしたい場合は、attr_wtiterメソッドを使う。

## 7.3.4 クラスメソッドの定義
- クラスに関係が深いものの、インスタンス変数に含まれるデータは使わないメソッドは、クラスメソッドとして定義する。
- クラスメソッドの定義方法は二つある。
### メソッド名にselfをつける。
```
class クラス名
  def self.クラスメソッド
    # クラスメソッドの処理
  end
end
```
### class<< selfからendの間にメソッドを書く。
```
class クラス名
  class << self
    def クラスメソッド
      # クラスメソッドの処理
    end
  end
end
```
## 7.3.5 定数
- クラスの中で定数を定義することができる。
  - 慣習的に、アフファベットの大文字と数字、アンダースコアで構成されることが多い。
- 定数は、インスタンスメソッド、クラスメソッドいずれでも、同じ方法で参照することができる。
# 7.5
- selfキーワードは、インスタンス自身を表す。
- メソッドの内部で他のメソッドを呼び出す時は、暗黙的にｓｅｌｆに対してメソッドを呼び出しているため、省略することが可能。
## 7.5.1 selfの付け忘れで不具合が発生するケース
- セッターメソッドにおいては、selfの付け忘れはローカル変数への代入と認識されているため、必ずselfを付ける必要がある。

## 7.5.2 クラスメソッドの内部やクラス構文直下のself
- selfは、場所によって「そのクラスのインスタンス自身」「クラス自身」を表したりする。

