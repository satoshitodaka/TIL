# 第1章
## 1-3
### 1-3-1 ボーイスカウトルール
- コードの修正が必要になった場合は、周囲を見渡してちょっとした修正を加えることが大切。
- 一つの修正の要件に対し、俯瞰して修正の範囲を広げると、実装を最適化できる可能性がある。
- 代表的なもの
  - 追加
  - 削除
  - 名前の変更
  - 分割
  - 構造化
### 1-3-2 YAGNI
- 不確定な将来に向けて、現在必要ない機能は実装するべきではない。結局使われないばかりか、将来のメンテナンス性や拡張性を損なうことがある。
- 不必要な「実装」を避けるべきであって、機能の必要性の検討などは、きちんと行わなければならない。
### 1-3-3 KISS
- コードは常に単純であるべき。
- コードは必ずしも綺麗で優雅である必要はなく、単純で読みやすいことが重要。
  - コードを綺麗にしようとすると、目的が曖昧になってしまうことがある。目的を考えて、愚直なコードを書くべし。
  - 例えば、テストの中でライブラリを使ってコードを綺麗に書く場合。
    - その値がテストにとってどう左右するか、テストでライブラリが使えるかどうか、目的が曖昧になってしまう。
### 1-3-4 単一責務
- 一つのクラスに負わせる責任・責務は一つに絞るべき。既存のクラスが複数の責務を持つ場合は分割する必要がある。
  - 実体に合わせてモデルを分割する。
  - ロジックを階層やコンポーネントに切り出す。
  - ユーティリティメソッドを別クラスに切り出す。
- クラスの要約を書き出してみて、簡単に書けなければ分割を検討する必要がある。
### 1-3-5 早計な最適化はしない
- 計算時間の短縮など、安易な最適化を軽率に行うべきではない。
- コンパイラやオプティマイザの最適化を妨げたり、コードの複雑性が増して可読性を下げることがある。
- 代表的な最適化
  - 可変オブジェクトの再利用・使い回し
  - インスタンスプール
  - 遅延初期化
  - キャッシュ
  - コードの重複を伴うインライン処理
- 一方で、コードを複雑にしない最適化は許容されるし、やるべき。
- また、複雑性を伴う最適化が必要な場合もある。その場合、目的を明確にして最適化に取り組むこと。最適化の対象の機能や、その頻度まで着目し、最適化の効果がキチンと得られるかを確認した上で取り組む。
